/*============================================================================
@file lpr_definition_npa_scheduler.c
 
Provides the sleep LPR definition for the /npa/scheduler node.
 
Copyright (c) 2010-2013 Qualcomm Technologies Incorporated.
All Rights Reserved.
Qualcomm Confidential and Proprietary

$Header: //components/rel/core.adsp/2.2/power/npa/src/scheduler/lpr_definition_npa_scheduler.c#2 $
============================================================================*/
#ifdef NPA_SCHEDULER_SLEEP_LPR_SUPPORTED
/* Only needed if Sleep LPR is defined */

#include "npa_scheduler_internal.h"
#include "npa_remote_rpm_protocol.h"
#include "sleep_v.h"
#include "CoreThread.h"
#include "timer.h"
        
/* ==================================================================
                GLOBAL DATA DECLARATIONS
   ================================================================== */
#define NPA_SCHEDULER_LPR_NODE_NAME "npa_scheduler"

/* ==================================================================
                LPR Definitions generated by Sleep
                via NPA Scheduler XML file.
   ================================================================== */

extern sleep_lprm SleepLPR_npa_scheduler_modes[];
extern sleep_lpr  SleepLPR_npa_scheduler;
   
/* ==================================================================
              INTERNAL FUNCTION DECLARATIONS
   ================================================================== */

/**
 * 
 * @brief npa_scheduler_calc_wakeup
 * 
 * Calculate the expected sleep absolute wakeup time.
 *
 * Note that the hard time is calculated as when Sleep will be
 * finished whereas soft time is when Sleep will wake up.  This
 * should not be an issue though as Scheduler's desired wakeup
 * will always be at or after the hard wakeup.
 * 
 * @param start_time: Time to use as base for absolute calculations.
 * @ soft_time_ptr: Passback of calculated soft time.
 * @ hard_time_ptr: Passback of calculated hard time.
 *
 * @return: Earliest expected wakeup time.
 * 
*/
static uint64 npa_scheduler_calc_wakeup(uint64 start_time,
                                        uint64 *soft_time_ptr,
                                        uint64 *hard_time_ptr)
{
  uint64 wakeup; 
  uint64 soft = UINT64_MAX; /* soft wakeup time not set */
  uint32 soft_duration; /* soft wakeup duration from now */
  npa_query_type query_result;
  
  /* assume hard is nearest */
  *hard_time_ptr = wakeup = sleep_get_hard_deadline();

  /* Get duration until soft time */
  CORE_VERIFY( NPA_QUERY_SUCCESS 
                 == npa_query( npa_scheduler.sleep.cpu_wakeup_query_handle,
                               SLEEP_QUERY_WAKEUP_TIME,
                               &query_result ) );
  soft_duration = query_result.data.value;

  /* see if soft time should be used */
  if (NPA_MAX_STATE != soft_duration)
  { /* have a valid soft time and not a "negative" number */
    soft = start_time + (uint64) soft_duration; /* calculate absolute time */

    if (npa_compare_times(soft, wakeup) < 0 )
    { /* soft time is sooner than hard time so use it */
      wakeup = soft;
      ++npa_scheduler.stats.soft_wakes_used;
    }
  }
  *soft_time_ptr = soft;

  return(wakeup);
}
   
/* ------------------------------------------------------------------
                  Scheduler SHUTDOWN LPRM FUNCTIONS
   ------------------------------------------------------------------ */                  
          
/**
 * 
 * @brief npa_scheduler_lpa_enter
 * 
 * This is the enter function that is called when this mode is being
 * entered during sleep.  In this case, we need to issue all the
 * forkable scheduler requests. 
 * 
 * @param duration_sclk: The amount of time we will sleep for in sclks.
 * 
*/
void npa_scheduler_lpr_enter( uint64 duration )
{
  uint64 start_time = CoreTimetick_Get64();
  uint64 func_duration;
  uint64 wakeup_time;
  uint64 soft_time;
  uint64 hard_time;


  ++npa_scheduler.stats.lpr_enter;

  if (0 == npa_sleep_lpr_supported)
  { /* no work to do or feature off so exit */
    return;
  }

  /* LPRs are in progress */
  npa_scheduler.sleep.enter = 1;

  /* Calc wakeup Time */
  wakeup_time = npa_scheduler_calc_wakeup(start_time,
                                          &soft_time,
                                          &hard_time);
  npa_scheduler.sleep.duration = duration;
  npa_scheduler.sleep.wakeup_time_ticks = wakeup_time;

  /* fork all pending scheduled requests with respect to the
   * expected sleep exit time and do implied cancel if
   * any are expected.
   */
  npa_run_scheduler_forks(wakeup_time);


  /* calculate function duration and record max */
  func_duration = npa_calc_duration(start_time,
                                    CoreTimetick_Get64(),
                                    &npa_scheduler.stats.lpr_entry_duration);

  ULOG_RT_PRINTF_7(npa_scheduler.log, 
                   "DONE npa_scheduler_lpr_enter"
                   " (wakeup_time: 0x%016llx)"
                   " (soft_time: 0x%016llx)"
                   " (hard_time: 0x%016llx)"
                   " (function duration: 0x%08x)",
                   ULOG64_LOWWORD(wakeup_time),
                   ULOG64_HIGHWORD(wakeup_time),
                   ULOG64_LOWWORD(soft_time),
                   ULOG64_HIGHWORD(soft_time),
                   ULOG64_LOWWORD(hard_time),
                   ULOG64_HIGHWORD(hard_time),
                   (uint32)func_duration);
}
             
/**
 * 
 * @brief npa_scheduler_lpr_exit
 * 
 * This is the exit function that is called when this mode is being
 * exited during sleep.  In this case, Scheduler will wake up
 * by the timer so no need to poke it. 
 * 
*/
void npa_scheduler_lpr_exit( void )
{
  uint64 start_time = CoreTimetick_Get64();
  uint64 func_duration;
  int64 time_to_request;

  ++npa_scheduler.stats.lpr_exit;

  if(0 == npa_sleep_lpr_supported )
  { /* feature turned off */
    return;
  }
  /* just a safety net */
  CORE_VERIFY(npa_scheduler.sleep.enter == 1);

  /* calculate time to next timeout */
  time_to_request = npa_compare_times(npa_scheduler.timer.current_timeout,
                                      CoreTimetick_Get64());

  if (0 != npa_scheduler.forked_queue.num_linked_clients
      || (0 != npa_scheduler.request_queue.num_linked_clients
          && time_to_request 
               <= (int) npa_scheduler.config_ptr->min_reschedule_delta))
  { /* have requests to handle  */
    if( npa_scheduler.clk_cpu_client)
    { /* Have work to do on exit to sleep so if clock exists, 
       * make sure clock is at the baseline. We do this before sleep has
       * the chance to reduce the clock.
       */
      npa_issue_suppressible_request( npa_scheduler.clk_cpu_client,
                                      npa_scheduler.config_ptr->clk_baseline);
    }
    /* disable the timer since NPA Scheduler is signalled from here */
    npa_scheduler_disable_timer();

    /* block timer from running but make sure only do it once */
    CORE_LOG_VERIFY(1 >= (++npa_scheduler.timer.deferred_match_count),
                    ULOG_RT_PRINTF_1( npa_scheduler.log, 
                                      "ERROR npa_scheduler_lpr_exit"
                                      " deferred_match_count %d"
                                      " is out of range",
                                      npa_scheduler.timer.deferred_match_count )
                    );
    timer_defer_match_interrupt_64();

    /* Tell scheduler to be same priority as sleep (current thread)
     * this way a signal to it will not cause a preemption of this task.
     */
    Core_SetThreadPriority(npa_scheduler.thread_id,
                           Core_GetThreadSelfPriority());

    /* Trigger scheduler that it has work to do when sleep is done */
    npa_scheduler_signal_task(NPA_SCHEDULER_ACTION_LPR_WAKEUP);
  }

  /* done processing */
  npa_scheduler.sleep.enter = 0;

  /* calculate function duration and record max */
  func_duration = npa_calc_duration(start_time,
                                    CoreTimetick_Get64(),
                                    &npa_scheduler.stats.lpr_exit_duration);

  /* TODO - Sleep logging may do this already.  Remove if so. */
  ULOG_RT_PRINTF_4( npa_scheduler.log,
                    "DONE npa_scheduler_lpr_exit"
                    " (desired_time: 0x%016llx)"
                    " (function duration: 0x%08x)"
                    " (time_to_request: 0x%08x)",
                    ULOG64_LOWWORD(npa_scheduler.timer.current_timeout),
                    ULOG64_HIGHWORD(npa_scheduler.timer.current_timeout),
                    (uint32)func_duration,
                    (uint32)time_to_request);
}

/* ==================================================================
              EXTERNAL FUNCTION DECLARATIONS
   ================================================================== */              
/**
 * 
 * @brief scheduler_lpr_init
 * 
 * Init function for the Scheduler LPR. 
 * 
 * Initialize the Scheduler LPR and then enables itself.
 *
*/
void npa_scheduler_lpr_init( void )
{
  if (npa_sleep_lpr_supported)
  { /* feature has not been turned off */
    CORE_VERIFY_PTR( 
      npa_scheduler.sleep.lpr_client 
        = npa_create_sync_client( NPA_SCHEDULER_SLEEP_LPR_RESOURCE_NAME, 
                                  "/npa/scheduler/lpr",
                  NPA_CLIENT_REQUIRED ) );

    /* register with sleep */
    sleep_define_lpr_str("npa_scheduler", npa_scheduler.sleep.lpr_client);

    /* create CPU Wakeup Client for getting soft wakeup time */
    CORE_VERIFY_PTR( 
      npa_scheduler.sleep.cpu_wakeup_query_handle
        = npa_create_query_handle( NPA_SCHEDULER_SLEEP_CORE_CPU_WAKEUP_RESOURCE_NAME ) );
  }
}

#endif /* NPA_SCHEDULER_SLEEP_LPR_SUPPORTED */
