;============================================================================
;  Name:
;    TIMER_SCRIPT.CMM
;
;  Description:
;    This script is used to help with the development 
;     and debugging of timers and timer clients.
;
; Copyright (c) 2013 QUALCOMM Technologies Incorporated.  
; All Rights Reserved.
; Qualcomm Confidential and Proprietary
;----------------------------------------------------------------------------
;============================================================================
;
;                        EDIT HISTORY FOR MODULE
;
; when       who     what, where, why
; -------    ---     --------------------------------------------------------
; 4/14/2013  cpaulo  Created.
;============================================================================;

GLOBAL &ret_get_timer_index
GLOBAL &processing_duration_entered
GLOBAL &next_expiry_val
GLOBAL &output_directory
GLOBAL &output_to_csv
GLOBAL &current_time
GLOBAL &current_time_from_str
GLOBAL &arg1
GLOBAL &arg2
GLOBAL &timer_group_list_check_ret
GLOBAL &check_timetick_internal_ret
GLOBAL &check_bin_in_list_ret
GLOBAL &get_IFH_ret_cid
GLOBAL &get_IFH_ret_timer_idx
GLOBAL &tt_from_interrupts
GLOBAL &tt_from_intr_str
GLOBAL &num_index_ret
GLOBAL &index_iterator_ret
GLOBAL &get_next_timetick_val_ret
GLOBAL &check_partial_log_ret

;============================================================================
; Global Defines

&FALSE=0x0
&TRUE=0x1
&num_debug_vars=0xA

;============================================================================
; Variables for getting the debug variable informations into merged logs

&debug_var0x1="timer_sets"								
&debug_var0x2="timers_expired_slave1"
&debug_var0x3="timers_expired_slave2"
&debug_var0x4="timers_expired_slave3"
&debug_var0x5="timer_expired_debug"
&debug_var0x6="timers_expired"
&debug_var0x7="timer_trace"
&debug_var0x8="record_match_val"
&debug_var0x9="timer_api_calls"
&debug_var0x0A="timer_defer_undefer_reference_count_log"
&debug_var0x0B="timers_remote_expired"

&debug_var_tt_name0x1="ts"
&debug_var_tt_name0x2="processing_started"
&debug_var_tt_name0x3="processing_started"
&debug_var_tt_name0x4="processing_started"
&debug_var_tt_name0x5="ts"
&debug_var_tt_name0x6="processing_started"
&debug_var_tt_name0x7="ts"
&debug_var_tt_name0x8="timer_now_supplied"
&debug_var_tt_name0x9="ts"
&debug_var_tt_name0x0A="ts"
&debug_var_tt_name0x0B="processing_started"

&debug_var_extra0x1=0x0
&debug_var_extra0x2=0x0
&debug_var_extra0x3=0x0
&debug_var_extra0x4=0x0
&debug_var_extra0x5=0x0
&debug_var_extra0x6=0x0
&debug_var_extra0x7="events"
&debug_var_extra0x8=0x0
&debug_var_extra0x9=0x0
&debug_var_extra0x0A=0x0
&debug_var_extra0x0B=0x0

&number_of_debug_vars=0x0B

&len_timer_sets=0
&index_timer_sets=0
&iterator_timer_sets=0
&first_traversal_timer_sets=0
&IS_THERE_timer_sets=&FALSE
&timetick_jump_timer_sets=&TRUE

&len_timers_expired=0
&index_timers_expired=0
&iterator_timers_expired=0
&first_traversal_timers_expired=0
&IS_THERE_timers_expired=&FALSE
&timetick_jump_timers_expired=&TRUE

&len_timer_expired_debug=0
&index_timer_expired_debug=0
&iterator_timer_expired_debug=0
&first_traversal_timer_expired_debug=0
&IS_THERE_timer_expired_debug=&FALSE
&timetick_jump_timer_expired_debug=&TRUE

&len_timers_expired_slave1=0
&index_timers_expired_slave1=0
&iterator_timers_expired_slave1=0
&first_traversal_timers_expired_slave1=0
&IS_THERE_timers_expired_slave1=&FALSE
&timetick_jump_timers_expired_slave1=&TRUE

&len_timers_expired_slave2=0
&index_timers_expired_slave2=0
&iterator_timers_expired_slave2=0
&first_traversal_timers_expired_slave2=0
&IS_THERE_timers_expired_slave2=&FALSE
&timetick_jump_timers_expired_slave2=&TRUE

&len_timers_expired_slave3=0
&index_timers_expired_slave3=0
&iterator_timers_expired_slave3=0
&first_traversal_timers_expired_slave3=0
&IS_THERE_timers_expired_slave3=&FALSE
&timetick_jump_timers_expired_slave3=&TRUE

&len_timer_trace=0
&index_timer_trace=0
&iterator_timer_trace=0
&first_traversal_timer_trace=0
&IS_THERE_timer_trace=&FALSE
&timetick_jump_timer_trace=&TRUE

&len_record_match_val=0
&index_record_match_val=0
&iterator_record_match_val=0
&first_traversal_record_match_val=0
&IS_THERE_record_match_val=&FALSE
&timetick_jump_record_match_val=&TRUE

&len_timer_api_calls=0
&index_timer_api_calls=0
&iterator_timer_api_calls=0
&first_traversal_timer_api_calls=0
&IS_THERE_timer_api_calls=&FALSE
&timetick_jump_timer_api_calls=&TRUE

&len_timer_defer_undefer_reference_count_log=0
&index_timer_defer_undefer_reference_count_log=0
&iterator_timer_defer_undefer_reference_count_log=0
&first_traversal_timer_defer_undefer_reference_count_log=0
&IS_THERE_timer_defer_undefer_reference_count_log=&FALSE
&timetick_jump_timer_defer_undefer_reference_count_log=&TRUE

&len_timers_remote_expired=0
&index_timers_remote_expired=0
&iterator_timers_remote_expired=0
&first_traversal_timers_remote_expired=0
&IS_THERE_timers_remote_expired=&FALSE
&timetick_jump_timers_remote_expired=&TRUE

;============================================================================

;============================================================================
; Get the arguments passed in.
;============================================================================
ENTRY &arg1_in &arg2_in &destination

&Presult=0
WE.AREA.RESet
WE.WINPOS 0. 0. 50% 100%
WE.AREA.Create TIMER
WE.AREA.view TIMER
;RADIX.DECIMAL
;setup.var.%SYMBOL
;setup.var.%HEX
  
  ; Setup vars to use hex, strings, symbols & index 
  SETUP.VAR %H %S %Y %I

  ; setup the scrip variables to use hex symbols
  radix HEX


print " "
print "######################################################################"
print " "
print "                       Timer Debug Script                             "
print " "
print "######################################################################"
print " "
print " "

&output_directory="C:\temp"
&output_to_csv=1
&processing_duration_entered=0

print "Main Option: &arg1_in"
print "Sub-menu Option: &arg2_in"
print "Dest: &destination"

IF "&destination"==""
(
  print "No destination directory listed!"
)
ELSE
(
  &output_directory="&destination"
)

&arg1=&arg1_in 
&arg2=&arg2_in

; Get current time
GOSUB ESTIMATE_CURRENT_TIME
PRINT "------------------------------------------------------------------"
PRINT "Doing a minimal check for timetick & timers still under processing"
PRINT "------------------------------------------------------------------"
GOSUB CHECK_FOR_TIMETICK &TRUE

;============================================================================
; Print the main menu contents, list options here.
;============================================================================

MENUSTART:
&inMainOption=""
&inSubOption=""
&numOptions=3
print " "
print "######################################################################"
print "                       M a i n   M e n u                              "
print "######################################################################"
print " "
print "1: Self Debug "
print "2: Auto Debug "
print "3: Power Debug "
print "0: Exit "
print ""

IF "&arg2"!=""
(
  &inSubOption=&arg2
  &arg2=""
)

IF "&arg1"==""
(
  ; Get input option
  enter &inMainOption
  print " "
)
ELSE
(
  &inMainOption=&arg1
  &arg1=""
)

; Verify input option
IF "&inMainOption"==""  
(
  GOTO MENUSTART
)

if &inMainOption>&numOptions
(
  print "Option not supported! Option Entered: &inMainOption Options Supported: &numOptions "
  print " "
  GOTO MENUSTART
)

print " "
print "Option &inMainOption input"
print " "

; Option 1
if &inMainOption==1
(
  GOSUB MENUSTART_SELF_DEBUG &inSubOption
)

; Option 2
if &inMainOption==2
(
  GOSUB MENUSTART_AUTO_DEBUG &inSubOption
)

; Option 3
if &inMainOption==3
(
  GOSUB MENUSTART_POWER_DEBUG &inSubOption
)

; Option 4
if &inMainOption==4
(
  GOSUB PRINT_UDS_LOGS
)

; Option 0
if &inMainOption==0
(
  PRINT "Exiting Timer Script..."
  ENDDO
)


; End, go back to the start
GOTO MENUSTART

ENDDO

MENUSTART_SELF_DEBUG:
ENTRY &arg_self
&numOptions=10
&inMainOptionSelf=0
print " "
print "######################################################################"
print "                     S e l f   D e b u g                              "
print "######################################################################"
print " "
print "1 : Check timer linked list "
print "2 : Traverse through timer linked list "
print "3 : Get Timer Structure from timer handle"
print "4 : Get Timer Group from Group handle"
print "5 : Check Recent Match Values "
print "6 : Check Recently Expired Timers "
print "7 : Check Timer Trace "
print "8 : Check Timers Set "
print "9 : Print Merged Timer Logs "
print "10: Check latest timetick & timetick jumps"
print "0 : Exit "
print ""


IF "&arg_self"==""
(
  ; Get input option
  enter &inMainOptionSelf
  print " "
)
ELSE
(
  &inMainOptionSelf=&arg_self
)

; Verify input option
IF "&inMainOptionSelf"==""
(
  GOTO MENUSTART_SELF_DEBUG
)

; Verify input option
if &inMainOptionSelf>&numOptions
(
  print "Option not supported! Option Entered: &inMainOption Options Supported: &numOptions "
  print " "
  GOSUB MENUSTART_SELF_DEBUG
)

print " "
print "Option &inMainOptionSelf input"
print " "

; Option 1
if &inMainOptionSelf==1
(
  GOSUB TIMER_LIST
  GOTO MENUSTART_SELF_DEBUG
)

; Option 3
if &inMainOptionSelf==3
(
  GOSUB GET_TIMER_INFO
  GOTO MENUSTART_SELF_DEBUG
)

; Option 2
if &inMainOptionSelf==2
(
  GOSUB TRAVERSE_TIMER_LIST
  GOTO MENUSTART_SELF_DEBUG
)

; Option 5
if &inMainOptionSelf==5
(
  GOSUB PRINT_RECENT_MATCH_VALUES
  GOTO MENUSTART_SELF_DEBUG
)

; Option 6
if &inMainOptionSelf==6
(
  GOSUB TIMERS_EXPIRED
  GOTO MENUSTART_SELF_DEBUG
)

; Option 7
if &inMainOptionSelf==7
(
  GOSUB TIMER_TRACE
  GOTO MENUSTART_SELF_DEBUG
)

; Option 8
if &inMainOptionSelf==8
(
  GOSUB TIMER_SETS
  GOTO MENUSTART_SELF_DEBUG
)

; Option 9
if &inMainOptionSelf==9
(
  GOSUB PRINT_MERGED_LOGS
  GOTO MENUSTART_SELF_DEBUG
)

; Option 10
if &inMainOptionSelf==10
(
  GOSUB CHECK_FOR_TIMETICK &TRUE
  GOTO MENUSTART_SELF_DEBUG
)

; Option 4
if &inMainOptionSelf==4
(
  GOSUB GET_GROUP_FROM_HANDLE
  GOTO MENUSTART_SELF_DEBUG
)

; Option 0
if &inMainOptionSelf==0
(
  PRINT "Exiting Self Debug..."
  RETURN
)
else
(
  PRINT "Wrong option selected"
  GOTO MENUSTART_SELF_DEBUG
)
RETURN

MENUSTART_AUTO_DEBUG:
print " "
print "######################################################################"
print "                      A u t o   D e b u g                             "
print "######################################################################"
print " "
print ""

GOSUB GENERAL_TIMER_DEBUG

RETURN

MENUSTART_POWER_DEBUG:
ENTRY &arg_power
&numOptions=2
&inMainOptionPower=0
print " "
print "######################################################################"
print "                     P o w e r   D e b u g                            "
print "######################################################################"
print " "
print "1: Find wakeup durations "
print "2: Find Non-deferrable Timers"
print "0: Exit "
print ""

IF "&arg_power"==""
(
  ; Get input option
  enter &inMainOptionPower
  print " "
)
ELSE
(
  &inMainOptionPower=&arg_power
)

; Verify input option
IF "&inMainOptionPower"==""
(
  GOTO MENUSTART_POWER_DEBUG
)

; Verify input option
if &inMainOptionPower>&numOptions
(
  print "Option not supported! Option Entered: &inMainOption Options Supported: &numOptions "
  print " "
  GOSUB MENUSTART_POWER_DEBUG
)

print " "
print "Option &inMainOptionPower input"
print " "

; Option 1
if &inMainOptionPower==1
(
  GOSUB TIMER_WAKEUP_DURATIONS
  GOTO MENUSTART_POWER_DEBUG
)

; Option 2
if &inMainOptionPower==2
(
  GOSUB TIMER_FIND_NON_DEFERRABLE_TIMERS
  GOTO MENUSTART_POWER_DEBUG
)

; Option 0
if &inMainOptionPower==0
(
  PRINT "Exiting Self Debug..."
  RETURN
)

RETURN

;============================================================================
; Subroutines go here.
;============================================================================

; Clear Window after each action
CLEAR_WINDOW:
  AREA.CLEAR INTRMENU
  AREA.RESET
RETURN

;============================================================================
; Internal subroutine for the handling of the uds log printing
;============================================================================
GET_GROUP_FROM_HANDLE:
print " "
print "######################################################################"
print "                      Get Group from handle                           "
print "######################################################################"
print " "
print ""
Print "Enter the group handle : "
print ""
ENTER &in_group_handle
print ""

  &in_group_handle=0x00000000FFFFFFFF&&in_group_handle

  ; values for handle comparision
  &GROUP_HANDLE_CONST=0XC3C3FFFF
  &GET_HANDLE_ONLY=0x0000FFFF


  &group_index=&in_group_handle&&GET_HANDLE_ONLY
  
  &gp_hndle_up=&in_group_handle^&GROUP_HANDLE_CONST
  &gp_hndle_up=&gp_hndle_up&0xFFFF0000
  &gp_hndle_up=&gp_hndle_up>>0x10
  &gp_hndle_dn=&in_group_handle&&GET_HANDLE_ONLY
  
  if (&gp_hndle_dn!=&gp_hndle_up)
	(
	  Print "Incorrect Group Handle entered"
	  RETURN
	)

  var.if (&group_index<0x0 || &group_index>0x40)	
	(
	  Print "Group index out ou bounds"
	  RETURN
	)   

  &name_grp=v.string(timer_internal_groups[&group_index])	
  &ext_self=v.string(timer_internal_groups[&group_index].ext_self)
  &disabled=v.value(timer_internal_groups[&group_index].disabled)
  &deferrable=v.value(timer_internal_groups[&group_index].deferrable)
  PRINT "Group : &name_grp"
  PRINT "  ext_self   = &ext_self"
  PRINT "  disabled   = &disabled"
  PRINT "  deferrable = &deferrable"
  PRINT ""
  PRINT ""
	
RETURN

;============================================================================
; Internal subroutine for the handling of the uds log printing
;============================================================================
PRINT_UDS_LOGS_INTERNAL:
  ENTRY &debug_var &timetick_var &force

  &is_there=Y.TYPE(&debug_var)
  var.if (&is_there==0x3 || &force==0x1)
   (
   	&total_size=v.sizeof(&debug_var)
	&unit_size=v.sizeof(&debug_var[0])
	&num_indexes=v.value(&total_size / &unit_size)
	
	&index_iterator=0x0
	
	while (&index_iterator<&num_indexes)
	  (
	    &timetick_val=v.value(&debug_var[&index_iterator].&timetick_var)
		&debug_var_str=var.string(&debug_var[&index_iterator])
		WRITE #7 "&timetick_val, &debug_var[&index_iterator] = , &debug_var_str"
	    &index_iterator=&index_iterator+0x1
	  )
   )
  else
   (
     PRINT "Timer-services debug var : '&debug_var' not available"
   )

RETURN
   
;============================================================================
; Get the timer chunk index & buffer index from the timer handle
;============================================================================   
GET_INDEX_FROM_HANDLE:
  ENTRY &qdi_timer_handle

  ; Init the gloabl ret value
  &get_IFH_ret_cid=0x0
  &get_IFH_ret_timer_idx=0x0
  
  &TIMER_HANDLE_CONSTANT=0xC3

  &temp=(&qdi_timer_handle>>0x18)&0xFF
  &get_IFH_ret_cid=(&qdi_timer_handle>>0x10)&0xFF
  &tid1=(&qdi_timer_handle>>0x8)&0xFF
  &tid0=&qdi_timer_handle&0xFF
   
  &temp_for_check=&get_IFH_ret_cid^&tid1^&tid0^&TIMER_HANDLE_CONSTANT

  if (&temp_for_check!=&temp)
    (
	  &get_IFH_ret_cid=0xFEEDF00D
	  &get_IFH_ret_timer_idx=0xFEEDF00D
	  ; Return since the passed timer handle is invalid
	  RETURN
	)
  
  ; Get the timer_index for the client chunk
  &get_IFH_ret_timer_idx=&qdi_timer_handle&0xFFFF
RETURN
   
;============================================================================
; Print the UDS logs in CSV format (in unsorted form)
;============================================================================
PRINT_UDS_LOGS:
  
  &uds_filename="timer_services_debug_vars.csv"
print " "
print "######################################################################"
print "                      Printing UDS Logs                              "
print "######################################################################"
print " "
print ""

  OPEN #7 &uds_filename /CREATE

  PRINT "... "
  GOSUB PRINT_UDS_LOGS_INTERNAL timer_sets ts 0x0
  PRINT "... "
  GOSUB PRINT_UDS_LOGS_INTERNAL timers_expired_slave1 processing_started 0x0
  PRINT "... "
  GOSUB PRINT_UDS_LOGS_INTERNAL timers_expired_slave2 processing_started 0x0
  PRINT "... "
  GOSUB PRINT_UDS_LOGS_INTERNAL timers_expired_slave3 processing_started 0x0
  PRINT "... "
  GOSUB PRINT_UDS_LOGS_INTERNAL timer_expired_debug ts 0x0
  PRINT "... "
  GOSUB PRINT_UDS_LOGS_INTERNAL timers_expired processing_started 0x0
  PRINT "... "
  
  ; Additional check for timer_trace
  &is_there_tt=Y.TYPE(timer_trace)
  if (&is_there_tt==0x3)
    (
    GOSUB PRINT_UDS_LOGS_INTERNAL timer_trace.events ts 0x1
	)
  PRINT "... "
  GOSUB PRINT_UDS_LOGS_INTERNAL record_match_val timer_now_supplied 0x0
  PRINT "... "
  GOSUB PRINT_UDS_LOGS_INTERNAL timer_api_calls ts 0x0
  PRINT "... "
  GOSUB PRINT_UDS_LOGS_INTERNAL timer_defer_undefer_reference_count_log ts 0x0

;------- Interrupt logs -------
   ; Have to think something for this section
   
  CLOSE #7

  PRINT ""
  PRINT "Completed printing the unified logs to : '&uds_filename'"
  PRINT ""

RETURN

;============================================================================
; Finds the largest timetick from the debug_log & checks for timetick jump
;============================================================================
PRINT_PROCESSING_TIMER_INFO:
  ENTRY &tmr_clt_ptr
  
  
  &tmr_clt_handle=v.value(*(uint32*)&tmr_clt_ptr)
  
  GOSUB GET_INDEX_FROM_HANDLE &tmr_clt_handle
  PRINT ""
  PRINT "Information of the Client Timer under processing :: "
  PRINT ""
  var.if (&get_IFH_ret_cid==0xFEEDF00D || &get_IFH_ret_timer_idx==0xFEEDF00D)
  (
      print "Timer handle does not appear to correct! Exiting..."
  )
  else
  (
    &tmr_ext_ptr=v.value(&timer_client_chunks[&get_IFH_ret_cid].buffer[&get_IFH_ret_timer_idx])

	GOSUB PRINT_EXT_TIMER_INFO &tmr_ext_ptr
	GOSUB EXTERNAL_TIMER_SANITY_CHECK &tmr_ext_ptr 0x1
	
	; Output the timer info in a window
	WINPOS 60% 0.0 40% 30% 0. 0. L1Info
	v.v %OPEN.1 timer_client_chunks[&get_IFH_ret_cid].buffer[&get_IFH_ret_timer_idx]
    
    ; Get the internal timer buffer index
    &tmr_int_handle_ptr=v.value(((timer_client_ptr_type)&tmr_ext_ptr)->timer_int_handle)
	&tmr_int_handle_ptr=&tmr_int_handle_ptr-1	
	
	var.if (&tmr_int_handle_ptr>=0x0 && &tmr_int_handle_ptr<=0x40 )
		(
		  &tmr_int_ptr=v.value(&timer_buffer_ptr[&tmr_int_handle_ptr])
          GOSUB PRINT_TIMER_INFO &tmr_int_ptr 1
		  GOSUB INTERNAL_TIMER_SANITY_CHECK &tmr_int_ptr 0x1
		  GOSUB INTERNAL_EXTERNAL_TIMER_MATCH &tmr_int_ptr &tmr_ext_ptr 0x1
		  WINPOS 60% 20% 40% 30% 0. 0. L1Info
		  v.v %OPEN.1 timer_buffer_ptr[&tmr_int_handle_ptr]
		)
  )

RETURN

;============================================================================
; Finds the largest timetick from the debug_log & checks for timetick jump
;============================================================================
CHECK_TIMETICK_INTERNAL:
  ENTRY &debug_var &timetick_var
  
  &tt_jump_index_string=""
  &check_timetick_internal_ret=0x0
  &num_index_ret=0x0
  &index_iterator_ret=0x0
  
  &timetick_jump=0x0
  &prev_timetick_val=0x0
  &largest_timetick_val=0x0
  &last_index_for_jump=0x0

  &total_size=v.sizeof(&debug_var)
  &unit_size=v.sizeof(&debug_var[0])
  &num_indexes=v.value(&total_size / &unit_size)
	
  &num_index_ret=&num_indexes
	
  &index_iterator=0x0
	
  while (&index_iterator<&num_indexes)
	  (
	    &timetick_val=v.value(&debug_var[&index_iterator].&timetick_var)

		if (&index_iterator==0x0)
		  (
		  &prev_timetick_val=&timetick_val
		  )
		else
		  (
		    if (&prev_timetick_val>&timetick_val)
			 (
			   &timetick_jump=&timetick_jump+1
			   if (&timetick_jump>1)
			     (
				  &tt_jump_index_string="&tt_jump_index_string"+"[&last_index_for_jump], "
				 )
			   &last_index_for_jump=&index_iterator
			 )
		   &prev_timetick_val=&timetick_val
		  )
	    
		if (&largest_timetick_val<&timetick_val)
		  (
		    &index_iterator_ret=&index_iterator
		    &largest_timetick_val=&timetick_val
		  )
		&index_iterator=&index_iterator+0x1
	  )
	  
	if (&timetick_jump>1)
	 (
	     &check_timetick_internal_ret=0xF00DF00D
	     &index_iterator_ret=0xFEEFD00D
	     PRINT "Timetick Jump Encountered in the debug var : '&debug_var' @ indexes : &tt_jump_index_string"
		 PRINT ""
	 )
	else
	 (
	   &check_timetick_internal_ret=&largest_timetick_val
	 )
	 
RETURN

;============================================================================
; Subroutine to check timetick jump & get the latest timetick value.
;============================================================================
CHECK_FOR_TIMETICK_DEREF:
  ENTRY &debug_var_name &tt_storage_type &extn
  
  &rain_check=Y.TYPE(&debug_var_name)
  var.if (&rain_check==0x3)
  (
   &IS_THERE_&debug_var_name=&TRUE
   if ("&extn"!="0x0")
    (
	  &debug_var_name_2="&debug_var_name"+".&extn"
	  GOSUB CHECK_TIMETICK_INTERNAL &debug_var_name_2 &tt_storage_type
	)
   else
    (
      GOSUB CHECK_TIMETICK_INTERNAL &debug_var_name &tt_storage_type
	)
   var.if (&check_timetick_internal_ret!=0xF00DF00D)
    (
      &timetick_jump_&debug_var_name=&FALSE
	
	; Setup the debug var params once & for all
      &len_&debug_var_name=&num_index_ret
      &index_&debug_var_name=&index_iterator_ret+0x1
   
	  &&deref_index="&index_&debug_var_name"
	  if (&deref_index==&num_index_ret)
	     (
 	     &index_&debug_var_name=0x0
		 )

      if (&current_time<&check_timetick_internal_ret)
	   (
	    &&deref_idx="&index_&debug_var_name"
		&deref_idx=&deref_idx-0x1
		if (&deref_idx<0x0)
		 (
		   &&deref_idx="&len_&debug_var_name"
		   &deref_idx=&deref_idx-0x1
		 )
	    &current_time_from_str="&debug_var_name[&deref_idx]"
	    &current_time=&check_timetick_internal_ret
	   )
    )
  )

RETURN


;============================================================================
; Subroutine to check timetick jump & get the latest timetick value.
;============================================================================
CHECK_FOR_TIMERS_UNDER_PROCESSING:
  ENTRY &debug_var_n
  
 &index_itr=0x0
 &&deref_length="&len_&debug_var_n"

 &&deref_is_there_n="&IS_THERE_&debug_var_n"
 &&deref_tt_jump_n="&timetick_jump_&debug_var_n"
  
  var.if (&deref_is_there_n==&FALSE || &deref_tt_jump_n==&TRUE)
   (
    RETURN
   )
 
 while (&index_itr<&deref_length)
 (
  &processing_val=v.value(&debug_var_n[&index_itr].processing_time)
  if (&processing_val==0xDEADBEEFD00DFEED)
   (
 	 &client_tmr_ptr=v.string(&debug_var_n[&index_itr].timer_expired)
	 PRINT ""
     PRINT "Expired timers still under processing, logged in = &debug_var_n[&index_itr]"
	 PRINT "timer=&client_tmr_ptr"
	 &client_tmr_ptr=v.value(&debug_var_n[&index_itr].timer_expired)
	 GOSUB PRINT_PROCESSING_TIMER_INFO &client_tmr_ptr
   )
  &index_itr=&index_itr+0x1
 )
 
RETURN

;============================================================================
; Subroutine to check timetick jump & get the latest timetick value.
;============================================================================
CHECK_FOR_TIMETICK:
 ENTRY &check_deadbeef
 &current_time=0x0
 &iterator=0x1
 &timetick_from_str=""

 while (&iterator<=&number_of_debug_vars)
   (
     ; Get the debug var name from the iterator
	 &&deref_debug_var_name="&debug_var&iterator"
	 &&deref_debug_tt_name="&debug_var_tt_name&iterator"
	 &&deref_debug_extn="&debug_var_extra&iterator"
	 
	 GOSUB CHECK_FOR_TIMETICK_DEREF &deref_debug_var_name &deref_debug_tt_name &deref_debug_extn
	
	if (&check_deadbeef!=&FALSE)
	(
	 var.if (&iterator==0x2 || &iterator==0x3 || &iterator==0x4 || &iterator==0x6)
	  (
	   ; Check for timers still under processing 
	   GOSUB CHECK_FOR_TIMERS_UNDER_PROCESSING &deref_debug_var_name
	  )	 
	)
	 ; increment the iterator
     &iterator=&iterator+0x1
   )
   
   &timetick_from_str="&current_time_from_str"

   ; Compare the largest obtained timetick value with timers.isr
   &tt_from_timers=v.value(\timer\timers.isr_time)
   if (&tt_from_timers>&current_time)
	(
	  &timetick_from_str="\timer\timers.isr_time"
	  &current_time=&tt_from_timers
	)

; Compare the largest obtained timetick value with the interrupt logs timetick value 
   if (&tt_from_interrupts>&current_time)
	(
	  &timetick_from_str="&tt_from_intr_str"
	  &current_time=&tt_from_interrupts
	)   
   
   PRINT "Checking the latest timetick from the debug vars & interrupt logs . . ."
   PRINT "Current Timetick Estimate = &current_time ; (obtained from &timetick_from_str)"
   PRINT ""
  
RETURN

;============================================================================
; Timer group list checking.
;============================================================================
TIMER_GROUP_LIST_CHECK:
  ENTRY &operation &timer_group_address
  ; &operation can be passed as 1 to check for a aprticular group address validity

  &timer_group_list_check_ret=0x0
  &break_thold=0xFF
  &group_start=v.value(&\timer\timers.active)
  &group_type="(timer_group_t_ptr)"
  &group_ptr=v.value((&group_type&group_start)->next)
  &last_group=&group_start
  &last_last_group=&group_start
  &grp_count=0x0
  &sym_grp=""

  if (&operation!=0x1)
   (
    PRINT "--- Timer group list checking ---"
   )
  
  var.if (&operation==0x1 && &group_start==&timer_group_address)
   (
     &timer_group_list_check_ret=0x1
	 &operation=0x0
     RETURN
   )
 
  var.if (&group_ptr==0x0)
	(
	  &sym_grp=v.string(&group_type&last_group)
	  if (&operation!=0x1)
	   (
	    PRINT "!! Group list seems incorrect or not yet initialized : &sym_grp"
		PRINT ""
	   )
	  &operation=0x0
	  RETURN
	)

  while &group_ptr!=&group_start
	(
      var.if (&operation==0x1 && &group_ptr==&timer_group_address)
        (
           &timer_group_list_check_ret=0x1
		   &operation=0x0
		   RETURN
		)
		
		&group_ptr=v.value((&group_type&group_ptr)->next)
		
		var.if (&group_ptr==0x0)
			(
			  if (&operation!=0x1)
	          (
			   &sym_grp=v.string(&group_type&last_group)
			  
			   PRINT "!! Group corrupted :           &sym_grp"
			   &sym_grp1=v.string(&group_type&group_ptr)
			   PRINT "(&group_type&sym_grp)->next  = &sym_grp1"
			   &sym_grp2=v.string(&group_type&last_last_group)
			   PRINT "(&group_type&sym_grp2)->next = &sym_grp"
			   PRINT ""
			  )
			  &operation=0x0
			  RETURN
			)
		&last_group=&group_ptr
		if &grp_count>=1
			(
			  &last_last_group=v.value((&group_type&last_last_group)->next)
			)
		
		&grp_count=&grp_count+1
		var.if (&grp_count>=&break_thold)
			(
			  if (&operation!=0x1)
			  (
			   PRINT "!! Suspicious group list, too many groups (more than &break_thold)"
			   PRINT ""
			  )
			  &operation=0x0
			  RETURN
			)
	)
	
  ;&grp_count=&grp_count-1

  if (&operation!=0x1)
  (
   PRINT "Group list is correct & proper"
   PRINT "Total groups = &grp_count"
   PRINT ""
  )

&operation=0x0
RETURN

;============================================================================
; Internal timer Sanity checking Subroutine.
;============================================================================
INTERNAL_TIMER_SANITY_CHECK:
  ENTRY &internal_timer_addr &silent_sanity_check

  &test_result=0x1
  &internal_timer_str=var.string((timer_internal_type*)&internal_timer_addr)
  
  if (&silent_sanity_check!=0x0)
  PRINT "-- Sanity test for the internal timer : &internal_timer_str ---"
  
  ;--------------------------------------------------------------------------
  ; Check the internal timer's index value
  &index_val=var.value(((timer_internal_type*)&internal_timer_addr)->index)
  &addr_from_index=var.value(&timer_buffer_ptr[&index_val])
  if (&internal_timer_addr!=&addr_from_index)
	(
	  PRINT "!! Internal timer: &internal_timer_str - index value is not pointing back to the same timer"
	  &test_result=0x0
	)	

  ;--------------------------------------------------------------------------
  ; Check the group sanity for the timer
  &group_var=var.value(((timer_internal_type*)&internal_timer_addr)->info.group_idx)
  var.if (&group_var<0x0 || &group_var>0x40)
	(
	  PRINT "!! Internal timer: &internal_timer_str - group index incorrect"
	  &test_result=0x0
	)

  ;--------------------------------------------------------------------------
  ; Check the slave task assignment for the timer
  &int_slave_task_idx=var.value(((timer_internal_type*)&internal_timer_addr)->info.slave_task_idx)
  var.if (&int_slave_task_idx<0x0 || &int_slave_task_idx>0x2)
	(
	  PRINT "!! Internal timer: &internal_timer_str - slave task assignment incorrect"
	  &test_result=0x0
	)	

  ;--------------------------------------------------------------------------
  ; Check the process index & remote process for the timer
  &int_remote_process=var.value(((timer_internal_type*)&internal_timer_addr)->info.remote_process)
  &int_process_idx=var.value(((timer_internal_type*)&internal_timer_addr)->info.process_idx)
  var.if (&int_remote_process!=0x0 && &int_remote_process!=0x3)
	(
	  PRINT "!! Internal timer: &internal_timer_str - remote process num incorrect"
	  &test_result=0x0
	)
  var.if (&int_remote_process==0x0 && &int_process_idx!=0x0)
	(
	  PRINT "!! Internal timer: &internal_timer_str - remote process is zero albeit process_idx != 0"
	  &test_result=0x0
	)	

  ;--------------------------------------------------------------------------
  ; Check the node status
  &int_node_state=var.value(((timer_internal_type*)&internal_timer_addr)->info.node_state)
  var.if (&int_node_state!=0x3 && &int_node_state!=0xC)
	(
	  PRINT "!! Internal timer: &internal_timer_str - Node status not correct"
	  &test_result=0x0
	)
	
  ;--------------------------------------------------------------------------
  ; check the timers list pointer	
  &list_val=var.value(((timer_internal_type*)&internal_timer_addr)->list)
  &active_list_val=v.value(&\timer\timers.active.list)
  if (&list_val!=&active_list_val)
	(
	  PRINT "!! Internal timer: &internal_timer_str - list not pointing to active timer list"
	  &test_result=0x0
	)	
  ;--------------------------------------------------------------------------	
  ; Minimal cache structure checking
  &reload_from_cache=var.value(((timer_internal_type*)&internal_timer_addr)->cache.reload_sclk)
  &reload_val=var.value(((timer_internal_type*)&internal_timer_addr)->reload)
  if (&reload_val!=&reload_from_cache)
	(
	  PRINT "!! Internal timer: &internal_timer_str - reload is not matching with the value in cache"
	  &test_result=0x0
	)		
  ;--------------------------------------------------------------------------	
  ; Checking for internal timer's next & prev pointers sanity
  ; Really bad logic used here (couldn't find any better way)
  &next_val=var.value(((timer_internal_type*)&internal_timer_addr)->next)
  &prev_val=var.value(((timer_internal_type*)&internal_timer_addr)->prev)
  &next_found=0x0
  &prev_found=0x0
  &iterator=0x0
  
  ; Go in a while loop searching every timer address to match with next & prev pointers
  while (&iterator<=0x40)
    (
	  &t_buff_addr=var.value(&timer_buffer_ptr[&iterator])
	  if (&next_val==&t_buff_addr)
		&next_found=0x1
	  if (&prev_val==&t_buff_addr)
		&prev_found=0x1
	
	  var.if (&next_found==0x1 && &prev_found==0x1)
	    &iterator=0xFF
	  
	  &iterator=&iterator+1
	)
	
  if (&next_found==0x0)
    (
      &last_timer_from_list=var.value(\timer\timers.active.list->last)
	  var.if (&last_timer_from_list==&internal_timer_addr && &next_val==0x0)
	  else
	   (
	    PRINT "!! Internal timer: &internal_timer_str - next pointer is corrupted"
	    &test_result=0x0
	   )
    )
  if (&prev_found==0x0)
    (
	  &first_timer_from_list=var.value(\timer\timers.active.list->first)
	  var.if (&first_timer_from_list==&internal_timer_addr && &prev_val==0x0)
	  else
	   (
	    PRINT "!! Internal timer: &internal_timer_str - prev pointer is corrupted"
	    &test_result=0x0
	   )
    )	
  	
  var.if (&silent_sanity_check!=0x0)
   (
   if (&test_result==0x0)
	(
	  PRINT "Sanity check for the timer failed : result above"
	)
  else
    (
	  PRINT "Internal Timer structure seems sane"
	)
  PRINT ""
   )
	
RETURN

;============================================================================
; External timer Sanity checking Subroutine.
;============================================================================
EXTERNAL_TIMER_SANITY_CHECK:
  ENTRY &external_timer_address &silent_int_sanity

  &ex_test_result=0x1
  &ex_external_timer_str=var.string((timer_client_ptr_type)&external_timer_address)
  if (&silent_int_sanity!=0x0)
  PRINT "--- Sanity test for the external timer : &ex_external_timer_str ---"

  ;--------------------------------------------------------------------------	
  ; Check if timer_state is a valid value only & also check the internal timer index
  &ex_timer_state=var.value(((timer_client_ptr_type)&external_timer_address)->timer_state)
  var.if (&ex_timer_state<0x0FEDCBA9 || &ex_timer_state>0x0FEDCBB0)
	(
	  PRINT "!! External timer: &ex_external_timer_str - Unknown timer state value"
	  &ex_test_result=0x0
	)
  else
	(
	  var.if (&ex_timer_state!=0x0FEDCBAF && &ex_timer_state!=0x0FEDCBAB)
	    (
         &ex_tmr_handle=var.value(((timer_client_ptr_type)&external_timer_address)->timer_int_handle)
		 var.if (&ex_tmr_handle!=-1)
		  (
		   &ex_test_result=0x0
		   PRINT "!! External timer: &ex_external_timer_str - state is neither SET / RESUMED & the timer_handle is containing some value"
		  )			
		)
	  else
	   (
	   	&ex_tmr_handle=var.value(((timer_client_ptr_type)&external_timer_address)->timer_int_handle)
		&ex_tmr_handle=&ex_tmr_handle-1
		var.if (&ex_tmr_handle<0x0 || &ex_tmr_handle>0x40)
		 (
          &ex_test_result=0x0
		  PRINT "!! External timer: &ex_external_timer_str - Internal timer index out of bounds"
		 )
	   )
	)   
  ;--------------------------------------------------------------------------
  ; Check the group sanity for the timer
  &ex_group_var=var.value(((timer_client_ptr_type)&external_timer_address)->info.group_idx)
  var.if (&ex_group_var<0x0 || &ex_group_var>0x40)
	(
	  PRINT "!! External timer: &ex_external_timer_str - group index out of bounds"
	  &ex_test_result=0x0
	)

  ;--------------------------------------------------------------------------
  ; Check the slave task assignment for the timer
  &ex_slave_task_idx=var.value(((timer_client_ptr_type)&external_timer_address)->info.slave_task_idx)
  var.if (&ex_slave_task_idx<0x0 || &ex_slave_task_idx>0x2)
	(
	  PRINT "!! External timer: &ex_external_timer_str - slave task assignment incorrect"
	  &ex_test_result=0x0
	)	

  ;--------------------------------------------------------------------------
  ; Check the process index & remote process for the timer
  &ex_remote_process=var.value(((timer_client_ptr_type)&external_timer_address)->info.remote_process)
  &ex_process_idx=var.value(((timer_client_ptr_type)&external_timer_address)->info.process_idx)
  var.if (&ex_remote_process!=0x0 && &ex_remote_process!=0x3)
	(
	  PRINT "!! External timer: &ex_external_timer_str - remote process num incorrect"
	  &ex_test_result=0x0
	)
  var.if (&ex_remote_process==0x0 && &ex_process_idx!=0x0)
	(
	  PRINT "!! External timer: &ex_external_timer_str - remote process is zero albeit process_idx != 0"
	  &ex_test_result=0x0
	)

  ;--------------------------------------------------------------------------
  ; Check the callback type
  &ex_callback_type=var.value(((timer_client_ptr_type)&external_timer_address)->info.callback_type)
  var.if (&ex_callback_type<0x0 || &ex_callback_type>0x3)
	(
	  PRINT "!! External timer: &ex_external_timer_str - callback type is incorrect"
	  &ex_test_result=0x0
	)		

  ;--------------------------------------------------------------------------
  ; Check the function type
  var.if (&ex_callback_type==0x2 || &ex_callback_type==0x3)
    (
	  &func_addr=var.value(((timer_client_ptr_type)&external_timer_address)->cbfn.func1)
	  &ex_func_name=Y.FUNCTION(P:&func_addr)
	  if "&ex_func_name"==""
	    (
		  PRINT "!! External timer: &ex_external_timer_str - cb function address seems to be incorrect"
		  &ex_test_result=0x0
		)
	)
	
  ;--------------------------------------------------------------------------
  ; Check the expiry type
  &ex_expiry_type=var.value(((timer_client_ptr_type)&external_timer_address)->info.expiry_type)
  var.if (&ex_expiry_type<0x0 || &ex_expiry_type>0x1)
	(
	  PRINT "!! External timer: &ex_external_timer_str - Unknown expiry type"
	  &ex_test_result=0x0
	)		
	
  ;--------------------------------------------------------------------------
  ; Check the node status
  &ex_node_state=var.value(((timer_client_ptr_type)&external_timer_address)->info.node_state)
  var.if (&ex_node_state!=0x3 && &ex_node_state!=0xC)
	(
	  PRINT "!! External timer: &ex_external_timer_str - Node status not correct"
	  &ex_test_result=0x0
	)

  if (&silent_int_sanity!=0x0)
  (
   if (&ex_test_result==0x0)
 	(
	  PRINT "Sanity check for the external timer failed : result above"
	)
   else
    (
	  PRINT "External timer structure seems sane"
	)
   PRINT ""
  )
	
RETURN

;============================================================================
; Timer List Subroutine.
;============================================================================
TIMER_LIST:
  print ""
  print ""
  print "######################################################################"
  print "                A c t i v e   T i m e r   L i s t                     "
  print "######################################################################"
  print ""
  print ""

  &iterator=0
  &last_iterator=0
  &tmr=v.value(\timer\timers.active.list.first)
  WHILE &tmr!=0
  (
    &q_status=v.value(((timer_ptr_internal_type)&tmr)->info.node_state)
    IF &q_status==0xC
    (
      &timer_index=var.string(((timer_ptr_internal_type)&tmr)->index)
      &timer_ext=var.string((((timer_ptr_internal_type)&tmr)->timer_ext))
      &expiry=var.value(((timer_ptr_internal_type)&tmr)->expiry)

      ;Print out list to screen
      print "Timer #" &iterator " -- Timer Index: &timer_index    External Timer: &timer_ext   Expiry: &expiry"
    )
    &iterator=&iterator+1
    &tmr=v.value(((timer_ptr_internal_type)&tmr)->next)
  )

  &last_iterator=&iterator

  print " "
  print " "

  print "Get more info on a timer? Enter 'y' if you would like to."

  print ""
  print ""

  ENTER &in_more_info

  IF "&in_more_info"=="y"
  (
    print "Please enter timer number from the list printed out above."
    print ""
    print ""

    ENTER &in_timer_number

    IF &in_timer_number<&last_iterator
    (
      &iterator=0
      &tmr=v.value(\timer\timers.active.list.first)
      WHILE &iterator<&in_timer_number
      (
        &iterator=&iterator+1
        &tmr=v.value(((timer_internal_type*)&tmr)->next)
      )
    
      IF &tmr!=0
      (
        GOSUB PRINT_TIMER_INFO &tmr &in_timer_number
      )
    )
    ELSE
    (
      print "Invalid timer number entered!"
      print ""
      print ""
    )

  )

RETURN

;============================================================================
; Recent Match Value Subroutine.
;============================================================================
PRINT_RECENT_MATCH_VALUES:
  print ""
  print ""
  print "######################################################################"
  print "              R e c e n t   M a t c h   V a l u e s                   "
  print "######################################################################"
  print ""
  print ""

  var.if (&IS_THERE_record_match_val==&FALSE || &timetick_jump_record_match_val==&TRUE)
	(
	PRINT "Debug Variable : 'record_match_val' might be not available or could be having timetick jumps"
    print ""
    print ""
    print ""
	RETURN
	)
  
  &to_print=0x0F
  
  if (&to_print>&len_record_match_val)
   (
     &to_print=&len_record_match_val
   )
  
  &end_idx=&index_record_match_val-0x1
  &start_idx=&end_idx-&to_print
  if (&start_idx<0x0)
   (
   &start_idx=&len_record_match_val-&to_print+&end_idx+0x1
   )
   
  &rmv_cnt=0x0
  &mv_setter_str=""

  AREA.CREATE TLO
  WINPOS 60% 30% 40% 70% 0. 0. TLO
  AREA.VIEW TLO
  AREA.SELECT TLO
  
  Print "Last &to_print match value entries from record_match_value"
  Print ""

  
  
  WHILE (&rmv_cnt<0xF)
  (
    &mv_setter=var.value(record_match_val[&start_idx].mv_setter)
    &timer_now_supplied=var.value(record_match_val[&start_idx].timer_now_supplied)
    &timer_match_value_actual_set=var.string(record_match_val[&start_idx].timer_match_value_actual_set)
    &timer_address=var.string((timer_type*)record_match_val[&start_idx].timer_address)

    ;TIMER_MVS_TIMER_PROCESSED = 0x1,
    IF &mv_setter==1
    (
      &mv_setter_str="Timer Processed"
    )
    ;TIMER_MVS_TIMER_SET,
    IF &mv_setter==2
    (
      &mv_setter_str="Timer Set"
    )
    ;TIMER_MVS_DEFER_MATCH_INT,
    IF &mv_setter==3
    (
      &mv_setter_str="Timers Deferred"
    )
    ;TIMER_MVS_UNDEFER_MATCH_INT,
    IF &mv_setter==4
    (
      &mv_setter_str="Timers Undeferred"
    )
    ;TIMER_MVS_GROUP_DISABLED,
    IF &mv_setter==5
    (
      &mv_setter_str="Timer Group Disabled"
    )
    ;TIMER_MVS_GROUP_ENABLED,
    IF &mv_setter==6
    (
      &mv_setter_str="Timer Group Enabled"
    )
    ;TIMER_MVS_TIMER_CLEARED,
    IF &mv_setter==7
    (
      &mv_setter_str="Timer Cleared"
    )
    ;TIMER_MVS_TIMER_PAUSED,
    IF &mv_setter==8
    (
      &mv_setter_str="Timer Paused"
    )
    ;TIMER_MVS_TIMER_RESUMED,
    IF &mv_setter==9
    (
      &mv_setter_str="Timer Resumed"
    )
    ;TIMER_MVS_TIMER_CLEAR_TASK_TIMERS,
    IF &mv_setter==10
    (
      &mv_setter_str="Task Timers Cleared"
    )
    ;TIMER_MVS_SET_WAKEUP,
    IF &mv_setter==11
    (
      &mv_setter_str="Wakeup Set"
    )

    ;Print out to screen
    print "record_match_val[&start_idx]: ----------------------------------"
	print "    MV Set Type: &mv_setter_str"
    print "    MV Set Time: &timer_now_supplied"
    print "    MV Set: &timer_match_value_actual_set"
    print "    Timer: &timer_address"
    
    &rmv_cnt=&rmv_cnt+0x1
	&start_idx=&start_idx+0x1
	if (&start_idx==&len_record_match_val)
	  (
	    &start_idx=0x0
	  )
  )
    Print "----------------------------------------------------------------"
  AREA.CLOSE TLO
  
  WINPOS 60% 0.0 40% 30% 0. 0. L1Info
  v.v %OPEN.1 record_match_val
  
  WE.AREA.select TIMER
  
  PRINT "Output put into the area window TLO for recent match value entries"
  PRINT "Oldest Index for 'record_match_val' = &index_record_match_val"
  
  print ""
  print ""
  print ""
RETURN


;============================================================================
; Timers Expired.
;============================================================================
TIMERS_EXPIRED:
  print ""
  print ""
  print "######################################################################"
  print "                    T i m e r s   E x p i r e d                       "
  print "######################################################################"
  print ""
  print ""
  
  var.if (&IS_THERE_timers_expired==&FALSE || &timetick_jump_timers_expired==&TRUE)
	(
	PRINT "Debug Variable : 'timers_expired' might be not available or could be having timetick jumps"
    print ""
    print ""
    print ""
	RETURN
	)
  
  &to_print=0x0A
  &cnt=0x0
  
  if (&to_print>&len_timers_expired)
   (
     &to_print=&len_timers_expired
   )
  
  &end_idx=&index_timers_expired-0x1
  &start_idx=&end_idx-&to_print
  if (&start_idx<0x0)
   (
   &start_idx=&len_timers_expired-&to_print+&end_idx+0x1
   )
   
  Print "Last &to_print timers_expired logs"
  Print ""  

  &sizeof_timers_expired=v.sizeof(timers_expired)/v.sizeof(timers_expired[0])
  &start_cnt=v.value(timer_expired_cnt)
  &iterator=1

  &new_out_dir="&output_directory"+"\timers_expired.csv"

  IF &output_to_csv==1
  (
    OPEN #1 &new_out_dir /Create
    WRITE #1 "Timer Expired,Expiry Value,Processing Started,Processing Time,Processing Ended,Function Address,Callback Type"
  )

  AREA.CREATE TLO
  WINPOS 60% 30% 40% 70% 0. 0. TLO
  AREA.VIEW TLO
  AREA.SELECT TLO

  Print "Last &to_print timers_expired logs"
  Print ""  
  
  WHILE &cnt<&to_print
  (
    &timer_expired=var.string(timers_expired[&start_idx].timer_expired)
    &expiry_value=var.value(timers_expired[&start_idx].expiry_value)
    &processing_started=var.value(timers_expired[&start_idx].processing_started)
    &processing_time=var.value(timers_expired[&start_idx].processing_time)
    &processing_end=var.value(timers_expired[&start_idx].processing_started)+&processing_time
    &fn_address=var.string(timers_expired[&start_idx].fn_address)
    &call_back_type=var.value(timers_expired[&start_idx].info.callback_type)
    
    ;Print out to screen
    print "timers_expired[&start_idx] :: --------------------------"
	print "        Timer Expired:      &timer_expired"
	print "        Expiry Value:       &expiry_value"  
	print "        Processing Started: &processing_started"  
	print "        Processing Ended:   &processing_end"  
	print "        Processing Time:    &processing_time"  
	print "        Function Address:   &fn_address"   
	print "        Callback Type:      &call_back_type"

    IF &output_to_csv==1
    (
      WRITE #1 "&timer_expired,&expiry_value,&processing_started,&processing_time,&processing_end,&fn_address,&call_back_type"
    )

    &cnt=&cnt+0x1
	&start_idx=&start_idx+0x1
	if (&start_idx==&len_timers_expired)
	 (
	   &start_idx=0x0
	 )
  )
    Print "----------------------------------------------------------------"
  AREA.CLOSE TLO
  
  WINPOS 60% 0.0 40% 30% 0. 0. L1Info
  v.v %OPEN.1 timers_expired
  
  WE.AREA.select TIMER
  
  PRINT "Output put into the area window TLO for recent expired timers"
  PRINT "Oldest Index for 'timers_expired' = &index_timers_expired"
  
  IF &output_to_csv==1
  (
    CLOSE #1
  )

  print ""
  print ""
  print ""
RETURN


;============================================================================
; Timer Trace.
;============================================================================
TIMER_TRACE:
  print ""
  print ""
  print "######################################################################"
  print "                       T i m e r   T r a c e                          "
  print "######################################################################"
  print ""
  print ""
  
  var.if (&IS_THERE_timer_trace==&FALSE || &timetick_jump_timer_trace==&TRUE)
	(
	PRINT "Debug Variable : 'timer_trace' is either not availale in this build or has timetick jumps"
    print ""
    print ""
    print ""
	RETURN
	)  
  
  &to_print=0x20
  &cnt=0x0
  
  if (&to_print>&len_timer_trace)
   (
     &to_print=&len_timer_trace
   )
  
  &end_idx=&index_timer_trace-0x1
  &start_idx=&end_idx-&to_print
  if (&start_idx<0x0)
   (
   &start_idx=&len_timer_trace-&to_print+&end_idx+0x1
   )
   
   
   
  
  AREA.CREATE TLO
  WINPOS 60% 30% 40% 70% 0. 0. TLO
  AREA.VIEW TLO
  AREA.SELECT TLO

  Print "Last &to_print timer_trace logs"
  Print ""  

  WHILE &cnt<&to_print
  (
    &event=var.string(timer_trace.events[&start_idx].event)
    &timestamp=var.value(timer_trace.events[&start_idx].ts)
    
    ;Print out to screen
    print "timer_trace[&start_idx]: Timestamp: &timestamp  Event: &event"

    &cnt=&cnt+0x1
	&start_idx=&start_idx+0x1
	if &start_idx==&len_timer_trace
	 (
	  &start_idx=0x0
	 )
  )

    Print "----------------------------------------------------------------"
  AREA.CLOSE TLO
  
  WINPOS 60% 0.0 40% 30% 0. 0. L1Info
  v.v %OPEN.1 timer_trace.events
  
  WE.AREA.select TIMER
  
  PRINT "Output put into the area window TLO for recent timer trace events"
  PRINT "Oldest Index for 'timer_trace' = &index_timer_trace"
  
  print ""
  print ""
  print ""
RETURN


;============================================================================
; Timer Sets.
;============================================================================
TIMER_SETS:
  print ""
  print ""
  print "######################################################################"
  print "                        T i m e r   S e t s                           "
  print "######################################################################"
  print ""
  print ""

  var.if (&IS_THERE_timer_sets==&FALSE || &timetick_jump_timer_sets==&TRUE)
	(
	PRINT "Debug Variable : 'timer_sets' is either not availale in this build or it has timetick jumps"
    print ""
    print ""
    print ""
	RETURN
	)    

  &end_idx=0x0
  &start_idx=0x0
  &to_print=0x20
  &cnt=0x0
  
  if (&to_print>&len_timer_sets)
   (
     &to_print=&len_timer_sets
   )

    &end_idx=&index_timer_sets-0x1
	&start_idx=&end_idx-&to_print
	if (&start_idx<0x0)
     ( 
     &start_idx=&len_timer_sets-&to_print+&end_idx+0x1
     )

   
  
  AREA.CREATE TLO
  WINPOS 60% 30% 40% 70% 0. 0. TLO
  AREA.VIEW TLO
  AREA.SELECT TLO

  Print "Last &to_print timer_sets logs"
  Print ""  	
	
  WHILE &cnt<&to_print
  (
    &timer_to_be_set=var.string(timer_sets[&start_idx].timer_to_be_set)
    &timestamp=var.value(timer_sets[&start_idx].ts)
    &expiry=var.value(timer_sets[&start_idx].expiry)
    
    ;Print out to screen
    print "timer_sets[&start_idx]: Timestamp: &timestamp  Expiry: &expiry  Timer: &timer_to_be_set"

    &cnt=&cnt+0x1
	&start_idx=&start_idx+0x1
	if (&start_idx==&len_timer_sets)
	  (
	    &start_idx=0x0
	  ) 
  )

  Print "----------------------------------------------------------------"
  AREA.CLOSE TLO
  
  WINPOS 60% 0.0 40% 30% 0. 0. L1Info
  v.v %OPEN.1 timer_sets
  
  WE.AREA.select TIMER
  
  PRINT "Output put into the area window TLO for recent timer sets events"
  PRINT "Oldest Index for 'timer_sets' = &index_timer_sets"
  
  print ""
  print ""
  print ""
RETURN


;============================================================================
; Find Wakeup Information.
;============================================================================
TIMER_WAKEUP_DURATIONS:

  AREA.CREATE TLO
  WINPOS 60% 30% 40% 70% 0. 0. TLO
  AREA.VIEW TLO
  AREA.SELECT TLO
  
  print ""
  print ""
  print "######################################################################"
  print "            T i m e r   W a k e u p  I n f o r m a t i o n            "
  print "######################################################################"
  print ""
  print ""
  &sizeof_timer_expired_debug=v.sizeof(timer_expired_debug)/v.sizeof(timer_expired_debug[0])
  &start_cnt=v.value(timer_expired_debug_cnt)
  &curr_cnt=v.value(timer_expired_debug_cnt)
  &iterator=1
  &skip_first_part=0
  &expiry_cnt=0
  &wakeup_number=1
  &outstring=""

  &out_dir_wakeup="&output_directory"+"\wakeups.txt"
  &out_dir_ulog="&output_directory"+"\timers.ulog"

  OPEN #2 &out_dir_wakeup /Create

  WRITE #2 ""
  WRITE #2 ""
  WRITE #2 "######################################################################"
  WRITE #2 "            T i m e r   W a k e u p  I n f o r m a t i o n            "
  WRITE #2 "######################################################################"
  WRITE #2 ""
  WRITE #2 ""

  ;Find the first clean timer expiry
  WHILE (var.value(timer_expired_debug[&curr_cnt].whileloopcnt)>1)&&(&curr_cnt<&sizeof_timer_expired_debug)
  (
    &curr_cnt=&curr_cnt+1
  )

  ;If we exited early
  IF &curr_cnt==&sizeof_timer_expired_debug
  (
    &curr_cnt=0
    WHILE (var.value(timer_expired_debug[&curr_cnt].whileloopcnt)>1)&&(&curr_cnt<&start_cnt)
    (
      &curr_cnt=&curr_cnt+1
    )
    &skip_first_part=1
  )

  &last_cnt=&curr_cnt
  &first_tmr=&curr_cnt
  ;Print first half
  WHILE (&curr_cnt<&sizeof_timer_expired_debug)&&(&skip_first_part==0)
  (
    ;Roll Over Case
    IF var.value(timer_expired_debug[&curr_cnt].whileloopcnt)==1
    (
      IF (&last_cnt-&first_tmr)>5
      (
        ;Print all timers in between
        &iterator=0
        &first_timestamp=v.value(timer_expired_debug[&first_tmr].ts)
        &last_timestamp=&first_timestamp
        WHILE &first_tmr<=&last_cnt
        (
          &timer_exp_ptr=var.string((timer_type*)timer_expired_debug[&first_tmr].timer_exp_ptr)
          &timestamp=var.value(timer_expired_debug[&first_tmr].ts)
          &expiry=var.value(timer_expired_debug[&first_tmr].expiry)
          &last_timestamp=&timestamp
          &iterator=&iterator+1
          &first_tmr=&first_tmr+1
          &outstring="#&iterator: Timestamp: &timestamp  Expiry: &expiry  Timer: &timer_exp_ptr"
          print "&outstring"
          WRITE #2 "&outstring"
        )

        &duration=&last_timestamp-&first_timestamp
        &duration_us=(&duration*10)/192

        print ""
        print ""
        print "Summary: Number of Timers Expired: " %decimal &iterator "  Total Wakeup Duration: " %decimal &duration  "  Total Wakeup Duration in Microseconds: " %decimal &duration_us
        print ""
        print ""

        WRITE #2 ""
        WRITE #2 ""
        WRITE #2 "Summary: Number of Timers Expired: " %decimal &iterator "  Total Wakeup Duration: " %decimal &duration  "  Total Wakeup Duration in Microseconds: " %decimal &duration_us
        WRITE #2 ""
        WRITE #2 ""
      )
      &first_tmr=&curr_cnt
      &last_cnt=&curr_cnt
    )
    ELSE
    (
      &last_cnt=&curr_cnt
    )
    
    &curr_cnt=&curr_cnt+1
  )

  &curr_cnt=0

  ;Print second half
  &last_cnt=&curr_cnt
  WHILE &curr_cnt<&start_cnt
  (
    ;Roll Over Case
    IF var.value(timer_expired_debug[&curr_cnt].whileloopcnt)==1
    (
      &total_first=0
      &total_last=0
      ;Wrap around case
      IF &last_cnt<&first_tmr
      (
        &total_first=(&sizeof_timer_expired_debug-&first_tmr)
        &total_last=&total_first+&last_cnt
      )
      ELSE
      (
        &total_first=&first_tmr
        &total_last=&last_cnt
      )
      IF ((&total_last-&total_first)>5)
      (
        ;Wrap Around Case
        IF &last_cnt<&first_tmr
        (
          ;Print all timers in between
          &iterator=0
          &first_timestamp=v.value(timer_expired_debug[&first_tmr].ts)
          &last_timestamp=0
          WHILE &first_tmr<&sizeof_timer_expired_debug
          (
            &timer_exp_ptr=var.string((timer_type*)timer_expired_debug[&first_tmr].timer_exp_ptr)
            &timestamp=var.value(timer_expired_debug[&first_tmr].ts)
            &expiry=var.value(timer_expired_debug[&first_tmr].expiry)
            &last_timestamp=&timestamp
            &iterator=&iterator+1
            &first_tmr=&first_tmr+1
            &outstring="#&iterator: Timestamp: &timestamp  Expiry: &expiry  Timer: &timer_exp_ptr"
            print "&outstring"
            WRITE #2 "&outstring"
          )

          &first_tmr=0
          WHILE &first_tmr<=&last_cnt
          (
            &timer_exp_ptr=var.string((timer_type*)timer_expired_debug[&first_tmr].timer_exp_ptr)
            &timestamp=var.value(timer_expired_debug[&first_tmr].ts)
            &expiry=var.value(timer_expired_debug[&first_tmr].expiry)
            &last_timestamp=&timestamp
            &iterator=&iterator+1
            &first_tmr=&first_tmr+1
            &outstring="#&iterator: Timestamp: &timestamp  Expiry: &expiry  Timer: &timer_exp_ptr"
            print "&outstring"
            WRITE #2 "&outstring"
          )

          &duration=&last_timestamp-&first_timestamp
          &duration_us=(&duration*10)/192

          print ""
          print ""
          print "Summary: Number of Timers Expired: " %decimal &iterator "  Total Wakeup Duration: " %decimal &duration "  Total Wakeup Duration in Microseconds: " %decimal &duration_us
          print ""
          print ""

          WRITE #2 ""
          WRITE #2 ""
          WRITE #2 "Summary: Number of Timers Expired: &iterator  Total Wakeup Duration: &duration  Total Wakeup Duration in Microseconds: &duration_us"
          WRITE #2 ""
          WRITE #2 ""
        )
        ELSE
        (
          ;Print all timers in between
          &iterator=0
          &first_timestamp=v.value(timer_expired_debug[&first_tmr].ts)
          &last_timestamp=0
          WHILE &first_tmr<=&last_cnt
          (
            &timer_exp_ptr=var.string((timer_type*)timer_expired_debug[&first_tmr].timer_exp_ptr)
            &timestamp=var.value(timer_expired_debug[&first_tmr].ts)
            &expiry=var.value(timer_expired_debug[&first_tmr].expiry)
            &last_timestamp=&timestamp
            &iterator=&iterator+1
            &first_tmr=&first_tmr+1
            &outstring="#&iterator: Timestamp: &timestamp  Expiry: &expiry  Timer: &timer_exp_ptr"
            print "&outstring"
            WRITE #2 "&outstring"
          )

          &duration=&last_timestamp-&first_timestamp
          &duration_us=(&duration*10)/192

          print ""
          print ""
          print "Summary: Number of Timers Expired: " %decimal &iterator "  Total Wakeup Duration: " %decimal &duration "  Total Wakeup Duration in Microseconds: " %decimal &duration_us
          print ""
          print ""

          WRITE #2 ""
          WRITE #2 ""
          WRITE #2 "Summary: Number of Timers Expired: &iterator  Total Wakeup Duration: &duration  Total Wakeup Duration in Microseconds: &duration_us"
          WRITE #2 ""
          WRITE #2 ""
        )
      )
      &first_tmr=&curr_cnt
      &last_cnt=&curr_cnt
    )
    ELSE
    (
      &last_cnt=&curr_cnt
    )
    &curr_cnt=&curr_cnt+1
  )

  CLOSE #2
  
  print ""
  print ""
  print "Output dumped to file in the location &out_dir_wakeup"
  print ""
  print ""
  print ""
  
  AREA.CLOSE TLO
  
  WE.AREA.select TIMER  
  
RETURN




;============================================================================
; Traverse Timer List Subroutine.
;============================================================================
TRAVERSE_TIMER_LIST:
  print ""
  print ""
  print "######################################################################"
  print "              T r a v e r s e   T i m e r   L i s t                   "
  print "######################################################################"
  print ""
  print ""

  ;Initialize exit parameter as 0
  &exit_param=0
  &in_param=0
  &in_param_found=0

  ;Initialize sequence number
  &seq_num=1
  &total_tmrs=0

  ;Initialize timer to use (head)
  &tmr=v.value(\timer\timers.active.list.first)

  IF &tmr==0
  (
    print "No timers on the timer linked list! Exiting Subroutine..."
    print ""
    print ""
    RETURN
  )

  ;Find total timers on linked list
  WHILE &tmr!=0
  (
    &total_tmrs=&total_tmrs+1
    &tmr=v.value(((timer_internal_type*)&tmr)->next)
  )

  ;Initialize timer to use (head)
  &tmr=v.value(\timer\timers.active.list.first)

  print "Starting with head of the timer linked list"
  print ""
  print ""

  ;Print head timer
  GOSUB PRINT_TIMER_INFO &tmr &seq_num

  ;Loop until we get exit cmd
  WHILE &exit_param==0
  (

    print "Please enter one of the following -- First:f   Next:n   Prev:p   Last:l   Exit:x"
    print ""
    print ""

    ;Wait for user input
    ENTER &in_param

    IF "&in_param"=="n"
    (
      IF v.value(((timer_internal_type*)&tmr)->next)==0
      (
        print "Cannot move forward in the linked list, already at tail!"
        print ""
        print ""
      )
      ELSE
      (
        &seq_num=&seq_num+1
        &tmr=v.value(((timer_internal_type*)&tmr)->next)
      )
      GOSUB PRINT_TIMER_INFO &tmr &seq_num
      &in_param_found=1
    )

    IF "&in_param"=="p"
    (
      IF &seq_num==1
      (
        print "Cannot move back in the timer linked list, already at the head!"
        print ""
        print ""
      )
      ELSE
      (
        &seq_num=&seq_num-1
        &tmr=v.value(((timer_internal_type*)&tmr)->prev)
      )
      GOSUB PRINT_TIMER_INFO &tmr &seq_num
      &in_param_found=1
    )

    IF "&in_param"=="f"
    (
      &seq_num=1
      &tmr=v.value(\timer\timers.active.list.first)
      GOSUB PRINT_TIMER_INFO &tmr &seq_num
      &in_param_found=1
    )

    IF "&in_param"=="l"
    (
      &seq_num=&total_tmrs
      &tmr=v.value(\timer\timers.active.list.last)
      GOSUB PRINT_TIMER_INFO &tmr &seq_num
      &in_param_found=1
    )

    IF "&in_param"=="x"
    (
      print "Exiting Traverse Subroutine..."
      print ""
      print ""
      RETURN
    )

    IF &in_param_found==0
    (

      print "Invalid Paramter Entered!"
      print ""
      print ""

    )

    ;Reinitialize value
    &in_param_found=0

  )

  ;Start with the head of the list
  ;GOSUB PRINT_TIMER_INFO &tmr 1


RETURN

;============================================================================
; Internal timer - External timer matching Subroutine.
;============================================================================
INTERNAL_EXTERNAL_TIMER_MATCH:
  ENTRY &int_timer_addr &ext_timer_addr &silent_match
  
  &int_timer_string_var=var.string((timer_internal_type*)&int_timer_addr)
  &ext_timer_string_var=var.string((timer_client_ptr_type)&ext_timer_addr)

  if (&silent_match!=0x0)
  PRINT "--- Checking Internal Timer vs. External Timer ---"
  
  &external_timer_addr=var.value(((timer_internal_type*)&int_timer_addr)->timer_ext)
  if (&external_timer_addr!=&ext_timer_addr)
	(
	  PRINT "!! Ext timer:(&ext_timer_string_var); Int timer(&int_timer_string_var) mismatch - timer_ext not matching with that in the internal timer buffer"
	)

  &int_timer_group=var.value(((timer_internal_type*)&int_timer_addr)->info.group_idx)
  &ext_timer_group=var.value(((timer_client_ptr_type)&ext_timer_addr)->info.group_idx)
  if (&int_timer_group!=&ext_timer_group)
	(
	  PRINT "!! Ext timer:(&ext_timer_string_var); Int timer(&int_timer_string_var) mismatch - group index mismatch"
    )

  &int_timer_slave_task=var.value(((timer_internal_type*)&int_timer_addr)->info.slave_task_idx)
  &ext_timer_slave_task=var.value(((timer_client_ptr_type)&ext_timer_addr)->info.slave_task_idx)
  if (&int_timer_slave_task!=&ext_timer_slave_task)
	(
	  PRINT "!! Ext timer:(&ext_timer_string_var); Int timer(&int_timer_string_var) mismatch - slave task number mismatch"
	)

  &int_process_idx=var.value(((timer_internal_type*)&int_timer_addr)->info.process_idx)
  &ext_process_idx=var.value(((timer_client_ptr_type)&ext_timer_addr)->info.process_idx)
  if (&int_process_idx!=&ext_process_idx)
	(
	  PRINT "!! Ext timer:(&ext_timer_string_var); Int timer(&int_timer_string_var) mismatch - process index not matching"
	)	
	
  &int_remote_process=var.value(((timer_internal_type*)&int_timer_addr)->info.remote_process)
  &ext_remote_process=var.value(((timer_client_ptr_type)&ext_timer_addr)->info.remote_process)
  if (&int_remote_process!=&ext_remote_process)
	(
	  PRINT "!! Ext timer:(&ext_timer_string_var); Int timer(&int_timer_string_var) mismatch - remote process mismatch"
	)

  &int_node_state=var.value(((timer_internal_type*)&int_timer_addr)->info.node_state)
  &ext_node_state=var.value(((timer_client_ptr_type)&ext_timer_addr)->info.node_state)
  if (&int_node_state!=&ext_node_state)
	(
	  PRINT "!! Ext timer:(&ext_timer_string_var); Int timer(&int_timer_string_var) mismatch - node status mismatch"
	)	
	
  if (&silent_match!=0x0)
  PRINT "Done checking for internal/external timer mismatch"
  
  RETURN
  
;============================================================================
; Get Internal Timer Index Subroutine.
;============================================================================
GET_TIMER_INDEX:
  ENTRY &ext_timer_handle &silent

  &ret_get_timer_index=0xFFFFFFFF

  var.if (&ext_timer_handle==0xDEADDEAD || &ext_timer_handle==0xFFFFFFFF || &ext_timer_handle==0xFFFFFFFFDEADDEAD)
	(
		RETURN
	)

  &ext_timer_handle=0x00000000FFFFFFFF&&ext_timer_handle

  ; values for handle comparision
  &TIMER_HANDLE_CONST=0x0000FFFF
  &VERIFY_XOR_HANDLE=0xFF000000

  &XOR_HANDLE=0x0
  &INT_TIMER_INDEX=0x0

  if (&silent!=1)
  (
    PRINT "External timer_handle = &ext_timer_handle"
  )

  &XOR_HANDLE=&ext_timer_handle&&VERIFY_XOR_HANDLE

  var.if (&XOR_HANDLE==0xC3000000)
	(
	&INT_TIMER_INDEX=&TIMER_HANDLE_CONST&&ext_timer_handle
	)
  else
	(
	&INT_TIMER_INDEX=&ext_timer_handle-1
	)

  ; Check if the internal timer index is valid
  var.if	(&INT_TIMER_INDEX>0xFF || &INT_TIMER_INDEX<0x0)
	(
	if (&silent!=1)
     (
	  PRINT ">> Internal Timer index is incorrect = &INT_TIMER_INDEX"
	  PRINT ""
	 )

	; Flag the return to notify that the handle is incorrect
	&ret_get_timer_index=0xDEADD00D
	RETURN
	)

if (&silent!=1)
  (	
  PRINT "Internal Timer index  = &INT_TIMER_INDEX"
  PRINT ""
  )
&ret_get_timer_index=&INT_TIMER_INDEX

 if (&silent==0x1)
	(
	  &silent=0x0
	)

RETURN

;============================================================================
; Get Timer Info Subroutine.
;============================================================================
GET_TIMER_INFO:
  print ""
  print ""
  print "######################################################################"
  print "                    G e t   T i m e r   I n f o                       "
  print "######################################################################"
  print ""
  print ""
  
  print "Please enter the timer handle"
  print ""
  print ""

  ENTER &in_timer_handle
  print ""
  print ""

  GOSUB GET_INDEX_FROM_HANDLE &in_timer_handle

  var.if (&get_IFH_ret_cid==0xFEEDF00D || &get_IFH_ret_timer_idx==0xFEEDF00D)
  (
      print "Timer handle does not appear to correct! Exiting..."
  )
  else
  (
    &tmr_ext=v.value(&timer_client_chunks[&get_IFH_ret_cid].buffer[&get_IFH_ret_timer_idx])

	GOSUB PRINT_EXT_TIMER_INFO &tmr_ext
	GOSUB EXTERNAL_TIMER_SANITY_CHECK &tmr_ext 0x1
	
	; Output the timer info in a window
	v.v timer_client_chunks[&get_IFH_ret_cid].buffer[&get_IFH_ret_timer_idx]
    
    ; Get the internal timer buffer index
    &tmr_int_handle=v.value(((timer_client_ptr_type)&tmr_ext)->timer_int_handle)
	&tmr_int_handle=&tmr_int_handle-1	
	
	var.if (&tmr_int_handle>=0x0 && &tmr_int_handle<=0x40 )
		(
		  &tmr_int=v.value(&timer_buffer_ptr[&tmr_int_handle])
          GOSUB PRINT_TIMER_INFO &tmr_int 1
		  GOSUB INTERNAL_TIMER_SANITY_CHECK &tmr_int 0x1
		  GOSUB INTERNAL_EXTERNAL_TIMER_MATCH &tmr_int &tmr_ext 0x1
		  v.v timer_buffer_ptr[&tmr_int_handle]
		)
  )

  print ""
  print ""


RETURN

;============================================================================
; Print Timer List Helper Function.
;============================================================================
PRINT_TIMER_INFO:

  ;Input parameter is the internal timer whose info will be printed
  ENTRY &internal_timer &sequence_number

  ;Print Spacer
  print "### Timer #&sequence_number ###"

  ;Print Index
  &timer_index=var.string(((timer_internal_type*)&internal_timer)->index)
  print "Timer Index:              &timer_index"
  
  ;Print External Timer
  &timer_ext=var.string(((timer_internal_type*)&internal_timer)->timer_ext)
  print "External Timer:           (timer_client_ptr_type)&timer_ext"

  ;Print Group
  &group_idx=var.value(((timer_internal_type*)&internal_timer)->info.group_idx)
  &group_str=var.str(timer_internal_groups[&group_idx])
  print "Timer Group:              &group_str"

  ;Print TCB (if available)
  &tcb=var.string(((timer_internal_type*)&internal_timer)->task_id)
  print "Client task_id:           &tcb"

  ;Print the callback type
  &timer_cb_type=var.value(((timer_internal_type*)&internal_timer)->timer_ext->info.callback_type)
  if (&timer_cb_type==0x0)
	(
	  PRINT "No callback notification used for the timer"
	)
  else if (&timer_cb_type==0x1)
    (
	  &sigs_obj=var.string(((timer_internal_type*)&internal_timer)->timer_ext->cbfn.sigs_obj)
      &sigs_val=var.value(((timer_internal_type*)&internal_timer)->timer_ext->cbdt.sigs)
      IF &sigs_val>0
      (
        print "Signal object:            &sigs_obj ;"
		print "Signal Mask  :            &sigs_val"
      )
	)
  else if (&timer_cb_type==0x2)
    (
	  &func1=var.string(((timer_internal_type*)&internal_timer)->timer_ext->cbfn.func1)
	  &cb_data=var.value(((timer_internal_type*)&internal_timer)->timer_ext->cbdt.data)
      print "Callback Type 1 Function: &func1 ; Data : &cb_data"
	)  
  else if (&timer_cb_type==0x3)
    (
	  &func1=var.string(((timer_internal_type*)&internal_timer)->timer_ext->cbfn.func1)
	  &cb_data=var.value(((timer_internal_type*)&internal_timer)->timer_ext->cbdt.data)
      print "Callback Type 2 Function: &func2 ; Data : &cb_data"
	)
  else
    (
	  PRINT "Invalid/Unknown callback type"
	)

  ; Print the timer list this timer is assigned to
  &tmr_list_allocated=var.string(((timer_internal_type*)&internal_timer)->list)  
  print "Timer List assigned:      &tmr_list_allocated"
  
  ; Print the slave task assigned to this timer
  &tmr_slave_task=var.value(((timer_internal_type*)&internal_timer)->info.slave_task_idx)  
  print "Slave Task Assigned:      &tmr_slave_task"
  
  ;Print Start Timetick
  &start=var.string(((timer_internal_type*)&internal_timer)->start)
  print "Start Timetick:           &start"

  ;Print Expiry Timetick
  &expiry=var.string(((timer_internal_type*)&internal_timer)->expiry)
  print "Expiry Timetick:          &expiry"

  ;Print State
  &timer_state=var.string(((timer_internal_type*)&internal_timer)->timer_ext->timer_state)
  print "Timer State:              &timer_state"

  ;Print Spacer
  print ""
  print ""

RETURN


;============================================================================
; Print External Timer Helper Function.
;============================================================================
PRINT_EXT_TIMER_INFO:

  ;Input parameter is the internal timer whose info will be printed
  ENTRY &external_timer

  ;Print Timer Name & Address
  &name=var.string((timer_client_ptr_type)&external_timer)
    print "Timer :                   &name"

  ;Print State
  &timer_state=var.string(((timer_client_ptr_type)&external_timer)->timer_state)
    print "Timer State:              &timer_state"
	
  &timer_state_ts=var.value(((timer_client_ptr_type)&external_timer)->timer_state_at)
    print "Timer State at:           &timer_state_ts"	

  &timer_buff_idx=var.value(((timer_client_ptr_type)&external_timer)->timer_int_handle)
    print "Timer Int buff idx:       &timer_buff_idx"
	
  ;Print Timer Callback information to Set
  &timer_cb_type=var.value(((timer_client_ptr_type)&external_timer)->info.callback_type)
  if (&timer_cb_type==0x0)
	(
	  PRINT "No callback notification used for the timer"
	)
  else if (&timer_cb_type==0x1)
    (
	  &sigs_obj=var.string(((timer_client_ptr_type)&external_timer)->cbfn.sigs_obj)
      &sigs_val=var.value(((timer_client_ptr_type)&external_timer)->cbdt.sigs)
      IF &sigs_val>0
      (
        print "Signal object:            &sigs_obj ;"
		print "Signal Mask  :            &sigs_val"
      )
	)
  else if (&timer_cb_type==0x2)
    (
	  &func1=var.string(((timer_client_ptr_type)&external_timer)->cbfn.func1)
	  &cb_data=var.value(((timer_client_ptr_type)&external_timer)->cbdt.data)
      print "Callback Type 1 Function: &func1 ; Data : &cb_data"
	)  
  else if (&timer_cb_type==0x3)
    (
	  &func1=var.string(((timer_client_ptr_type)&external_timer)->cbfn.func1)
	  &cb_data=var.value(((timer_client_ptr_type)&external_timer)->cbdt.data)
      print "Callback Type 2 Function: &func2 ; Data : &cb_data"
	)
  else
    (
	  PRINT "Invalid/Unknown callback type"
	)  

  ;Print Group Info
  &group_idx=var.value(((timer_client_ptr_type)&external_timer)->info.group_idx)
  &group_str=var.str(timer_internal_groups[&group_idx])
  print "Timer Group:              &group_str"	
	
  ;Print Timer Slave Task Assigned
  &slave_assigned=var.value(((timer_client_ptr_type)&external_timer)->info.slave_task_idx)
    print "Slave Task Assigned:      &slave_assigned"

  ;Print Process Index
  &process_idx=var.value(((timer_client_ptr_type)&external_timer)->info.process_idx)
    print "Process Index:            &process_idx"

  ;Print Remote process information
  &remote_process=var.value(((timer_client_ptr_type)&external_timer)->info.remote_process)
    print "Remote Process:           &remote_process"
	
  ;Print Expiry type information
  &expiry_type=var.value(((timer_client_ptr_type)&external_timer)->info.expiry_type)
    if (&expiry_type==0x0)
	    print "Expiry Type:              TIMER_ABSOLUTE_EXPIRY"
	else if (&expiry_type==0x1)
	    print "Expiry Type:              TIMER_RELATIVE_EXPIRY"
	else
	    print "Unknown Expiry type: &expiry_type"
	
  ;Print Timer Slave Task Assigned
  &node_state=var.value(((timer_client_ptr_type)&external_timer)->info.node_state)
  if (&node_state==0x03)
    print "Node Status:              NODE_IS_FREE"	
  else if (&node_state==0x0C)
	print "Node Status:              NODE_IS_NOT_FREE"
  else
    print "Unknown Node Status:  &node_state"

	;Print Spacer
    print ""

RETURN


;============================================================================
; Search for Non-deferrable Timers.
;============================================================================
TIMER_FIND_NON_DEFERRABLE_TIMERS:

  AREA.CREATE TLO
  WINPOS 60% 30% 40% 70% 0. 0. TLO
  AREA.VIEW TLO
  AREA.SELECT TLO

  &ret=0x0

  print ""
  print ""
  print "######################################################################"
  print "         F i n d   N o n - D e f e r r a b l e   T i m e r s          "
  print "######################################################################"
  print ""
  print ""
  &sizeof_timers_expired=v.sizeof(timers_expired)/v.sizeof(timers_expired[0])
  &sizeof_timers_expired_slave1=0
  &sizeof_timers_expired_slave2=0
  &sizeof_timers_expired_slave3=0
  &ret=y.type(timers_expired_slave1)
  IF (&ret==0x3)
  (
    &sizeof_timers_expired_slave1=v.sizeof(timers_expired_slave1)/v.sizeof(timers_expired_slave1[0])
  )
  &ret=y.type(timers_expired_slave2)
  IF (&ret==0x3)
  (
    &sizeof_timers_expired_slave2=v.sizeof(timers_expired_slave2)/v.sizeof(timers_expired_slave2[0])
  )
  &ret=y.type(timers_expired_slave3)
  IF (&ret==0x3)
  (
    &sizeof_timers_expired_slave3=v.sizeof(timers_expired_slave3)/v.sizeof(timers_expired_slave3[0])
  )
  &start_cnt=v.value(timer_expired_cnt)
  &curr_cnt=v.value(timer_expired_cnt)
  &iterator=1

  &out_dir_ulog="&output_directory"+"\timers.ulog"

  OPEN #3 &out_dir_ulog /Create

  print "======================================================"
  print " Checking Expired Non-deferrable Timers On Timer Task "
  print "======================================================"
  print ""

  ;Print first half
  WHILE &curr_cnt<&sizeof_timers_expired
  (
    &timer_expired=var.string(timers_expired[&curr_cnt].timer_expired)
    &timer_expired_val=var.value(timers_expired[&curr_cnt].timer_expired)
    &group_idx=var.value((timers_expired[&curr_cnt].info.group_idx))
    &deferrable=var.value(timer_internal_groups[&group_idx].deferrable)
	&group_str=var.string(timer_internal_groups[&group_idx])
    &expiry_value=var.value(timers_expired[&curr_cnt].expiry_value)
    &processing_started=var.value(timers_expired[&curr_cnt].processing_started)
    
    ;Print out to screen
    IF (&deferrable==0)&&(&timer_expired_val!=0)
    (
      &outstring_ulog="&processing_started: Non-deferrable timer expiry.  Expiry Value: &expiry_value  Timer Expired: &timer_expired  Group: &group_str"
      print "&iterator: Expiry Value: &expiry_value  Processing Started: &processing_started  Timer Expired: &timer_expired  Group: &group_str"
      WRITE #3 "&outstring_ulog"
      &iterator=&iterator+1
    )
    &curr_cnt=&curr_cnt+1
  )

  &curr_cnt=0
  ;Print second half
  WHILE &curr_cnt<&start_cnt
  (
    &timer_expired=var.string(timers_expired[&curr_cnt].timer_expired)
    &timer_expired_val=var.value(timers_expired[&curr_cnt].timer_expired)
    &group_idx=var.value((timers_expired[&curr_cnt].info.group_idx))
    &deferrable=var.value(timer_internal_groups[&group_idx].deferrable)
	&group_str=var.string(timer_internal_groups[&group_idx])
    &expiry_value=var.value(timers_expired[&curr_cnt].expiry_value)
    &processing_started=var.value(timers_expired[&curr_cnt].processing_started)
    
    ;Print out to screen
    IF (&deferrable==0)&&(&timer_expired_val!=0)
    (
      &outstring_ulog="&processing_started: Non-deferrable timer expiry.  Expiry Value: &expiry_value  Timer Expired: &timer_expired  Group: &group_str"
      print "&iterator: Expiry Value: &expiry_value  Processing Started: &processing_started  Timer Expired: &timer_expired  Group: &group_str"
      WRITE #3 "&outstring_ulog"
      &iterator=&iterator+1
    )
    &curr_cnt=&curr_cnt+1
  )


  &ret=y.type(timers_expired_slave1)
  IF (&ret==0x3)
  (
    print "======================================================="
    print " Checking Expired Non-deferrable Timers On Slave1 Task "
    print "======================================================="
    print ""
    &start_cnt=v.value(timer_expired_cnt_slave1)
    &curr_cnt=v.value(timer_expired_cnt_slave1)
    ;Print first half
    WHILE &curr_cnt<&sizeof_timers_expired_slave1
    (
      &timer_expired=var.string(timers_expired_slave1[&curr_cnt].timer_expired)
      &timer_expired_val=var.value(timers_expired_slave1[&curr_cnt].timer_expired)
      &group=var.string((struct timer_group_struct*)(timers_expired_slave1[&curr_cnt].timer_expired->group))
      &deferrable=var.value((struct timer_group_struct*)((timers_expired_slave1[&curr_cnt].timer_expired->group)->deferrable))
      &processing_started=var.value(timers_expired_slave1[&curr_cnt].processing_started)
      
      ;Print out to screen
      IF (&deferrable==0)&&(&timer_expired_val!=0)
      (
        &outstring_ulog="&processing_started: Non-deferrable timer expiry.  Expiry Value: &expiry_value  Timer Expired: &timer_expired  Group: &group"
        WRITE #3 "&outstring_ulog"
        print "&iterator: Processing Started: &processing_started  Timer Expired: &timer_expired  Group: &group"
        &iterator=&iterator+1
      )
      &curr_cnt=&curr_cnt+1
    )

    &curr_cnt=0
    ;Print second half
    WHILE &curr_cnt<&start_cnt
    (
      &timer_expired=var.string(timers_expired_slave1[&curr_cnt].timer_expired)
      &timer_expired_val=var.value(timers_expired_slave1[&curr_cnt].timer_expired)
      &group=var.string((struct timer_group_struct*)(timers_expired_slave1[&curr_cnt].timer_expired->group))
      &deferrable=var.value((struct timer_group_struct*)((timers_expired_slave1[&curr_cnt].timer_expired->group)->deferrable))
      &processing_started=var.value(timers_expired_slave1[&curr_cnt].processing_started)
      
      ;Print out to screen
      IF (&deferrable==0)&&(&timer_expired_val!=0)
      (
        &outstring_ulog="&processing_started: Non-deferrable timer expiry.  Expiry Value: &expiry_value  Timer Expired: &timer_expired  Group: &group"
        WRITE #3 "&outstring_ulog"
        print "&iterator: Processing Started: &processing_started  Timer Expired: &timer_expired  Group: &group"
        &iterator=&iterator+1
      )
      &curr_cnt=&curr_cnt+1
    )
  )

  &ret=y.type(timers_expired_slave2)
  IF (&ret==0x3)
  (
    print "======================================================="
    print " Checking Expired Non-deferrable Timers On Slave2 Task "
    print "======================================================="
    print ""
    &start_cnt=v.value(timer_expired_cnt_slave2)
    &curr_cnt=v.value(timer_expired_cnt_slave2)
    ;Print first half
    WHILE &curr_cnt<&sizeof_timers_expired_slave2
    (
      &timer_expired=var.string(timers_expired_slave2[&curr_cnt].timer_expired)
      &timer_expired_val=var.value(timers_expired_slave2[&curr_cnt].timer_expired)
      &group=var.string((struct timer_group_struct*)(timers_expired_slave2[&curr_cnt].timer_expired->group))
      &deferrable=var.value((struct timer_group_struct*)((timers_expired_slave2[&curr_cnt].timer_expired->group)->deferrable))
      &processing_started=var.value(timers_expired_slave2[&curr_cnt].processing_started)
      
      ;Print out to screen
      IF (&deferrable==0)&&(&timer_expired_val!=0)
      (
        &outstring_ulog="&processing_started: Non-deferrable timer expiry.  Expiry Value: &expiry_value  Timer Expired: &timer_expired  Group: &group"
        WRITE #3 "&outstring_ulog"
        print "&iterator: Processing Started: &processing_started  Timer Expired: &timer_expired  Group: &group"
        &iterator=&iterator+1
      )
      &curr_cnt=&curr_cnt+1
    )

    &curr_cnt=0
    ;Print second half
    WHILE &curr_cnt<&start_cnt
    (
      &timer_expired=var.string(timers_expired_slave2[&curr_cnt].timer_expired)
      &timer_expired_val=var.value(timers_expired_slave2[&curr_cnt].timer_expired)
      &group=var.string((struct timer_group_struct*)(timers_expired_slave2[&curr_cnt].timer_expired->group))
      &deferrable=var.value((struct timer_group_struct*)((timers_expired_slave2[&curr_cnt].timer_expired->group)->deferrable))
      &processing_started=var.value(timers_expired_slave2[&curr_cnt].processing_started)
      
      ;Print out to screen
      IF (&deferrable==0)&&(&timer_expired_val!=0)
      (
        &outstring_ulog="&processing_started: Non-deferrable timer expiry.  Expiry Value: &expiry_value  Timer Expired: &timer_expired  Group: &group"
        WRITE #3 "&outstring_ulog"
        print "&iterator: Processing Started: &processing_started  Timer Expired: &timer_expired  Group: &group"
        &iterator=&iterator+1
      )
      &curr_cnt=&curr_cnt+1
    )
  )

  &ret=y.type(timers_expired_slave3)
  IF (&ret==0x3)  
  (
    print "======================================================="
    print " Checking Expired Non-deferrable Timers On Slave3 Task "
    print "======================================================="
    print ""
    &start_cnt=v.value(timer_expired_cnt_slave3)
    &curr_cnt=v.value(timer_expired_cnt_slave3)
    ;Print first half
    WHILE &curr_cnt<&sizeof_timers_expired_slave3
    (
      &timer_expired=var.string(timers_expired_slave3[&curr_cnt].timer_expired)
      &timer_expired_val=var.value(timers_expired_slave3[&curr_cnt].timer_expired)
      &group=var.string((struct timer_group_struct*)(timers_expired_slave3[&curr_cnt].timer_expired->group))
      &deferrable=var.value((struct timer_group_struct*)((timers_expired_slave3[&curr_cnt].timer_expired->group)->deferrable))
      &processing_started=var.value(timers_expired_slave3[&curr_cnt].processing_started)
      
      ;Print out to screen
      IF (&deferrable==0)&&(&timer_expired_val!=0)
      (
        &outstring_ulog="&processing_started: Non-deferrable timer expiry.  Expiry Value: &expiry_value  Timer Expired: &timer_expired  Group: &group"
        WRITE #3 "&outstring_ulog"
        print "&iterator: Processing Started: &processing_started  Timer Expired: &timer_expired  Group: &group"
        &iterator=&iterator+1
      )
      &curr_cnt=&curr_cnt+1
    )

    &curr_cnt=0
    ;Print second half
    WHILE &curr_cnt<&start_cnt
    (
      &timer_expired=var.string(timers_expired_slave3[&curr_cnt].timer_expired)
      &timer_expired_val=var.value(timers_expired_slave3[&curr_cnt].timer_expired)
      &group=var.string((struct timer_group_struct*)(timers_expired_slave3[&curr_cnt].timer_expired->group))
      &deferrable=var.value((struct timer_group_struct*)((timers_expired_slave3[&curr_cnt].timer_expired->group)->deferrable))
      &processing_started=var.value(timers_expired_slave3[&curr_cnt].processing_started)
      
      ;Print out to screen
      IF (&deferrable==0)&&(&timer_expired_val!=0)
      (
        &outstring_ulog="&processing_started: Non-deferrable timer expiry.  Expiry Value: &expiry_value  Timer Expired: &timer_expired  Group: &group"
        WRITE #3 "&outstring_ulog"
        print "&iterator: Processing Started: &processing_started  Timer Expired: &timer_expired  Group: &group"
        &iterator=&iterator+1
      )
      &curr_cnt=&curr_cnt+1
    )
  )

  print ""
  print ""
  print "==========================================="
  print " Checking for Active Non-deferrable Timers "
  print "==========================================="
  print ""

  &tmr=v.value(\timer\timers.active.list.first)
  &iterator=1

  WHILE &tmr!=0
  (
    &group_idex=v.value(((timer_internal_type*)&tmr)->info.group_idx)
	&deferrable=v.value(timer_internal_groups[&group_idex].deferrable)

    IF &deferrable==0
    (
      print "Deferrable Timer #&iterator in linked list:"
      GOSUB PRINT_TIMER_INFO &tmr &iterator
      &iterator=&iterator+1
    )

    &tmr=v.value(((timer_internal_type*)&tmr)->next)
  )

  CLOSE #3
  print "ULog file output in the following directory: &out_dir_ulog"

  print ""
  print ""
  print ""
  
  AREA.CLOSE TLO
  
  WE.AREA.select TIMER
  
RETURN

;============================================================================
; Reset the starting index iterator for the respective debug vars.
;============================================================================
RESET_DEBUG_VAR_ITERATOR:

&iterator=0x1

 while (&iterator<=&number_of_debug_vars)
   (
     ; Get the debug var name from the iterator
	 &&deref_debug_var_name="&debug_var&iterator"
 
	 ; Get the starting index deref for the debug var
	 &&defer_index="&index_&deref_debug_var_name"
	 
	 ; reinitialize the value
	 &iterator_&deref_debug_var_name=&defer_index
	 &first_traversal_&deref_debug_var_name=&TRUE
 
	 ; increment the iterator
     &iterator=&iterator+0x1
   )

RETURN

;============================================================================
; Reset the starting index iterator for the respective debug vars.
;============================================================================
GET_NEXT_TIMETICK_VAL:
  ENTRY &dbg_var_id

  &get_next_timetick_val_ret=0xFEEDF00D
  
  &&deref_dbg_var_name="&debug_var&dbg_var_id"
  &&deref_dbg_tt_name="&debug_var_tt_name&dbg_var_id"
  &&deref_dbg_extra="&debug_var_extra&dbg_var_id"
  
  &&deref_len="&len_&deref_dbg_var_name"
  &&deref_index="&index_&deref_dbg_var_name"
  &&deref_iterator="&iterator_&deref_dbg_var_name"
  &&deref_is_there="&IS_THERE_&deref_dbg_var_name"
  &&deref_tt_jump="&timetick_jump_&deref_dbg_var_name"
  
  var.if (&deref_is_there==&FALSE || &deref_tt_jump==&TRUE)
   (
    RETURN
   )
  
  ; reset the iterator to zero if it has reached the boundry
  if (&deref_iterator==&deref_len)
   (
   &iterator_&deref_dbg_var_name=0x0
   )
 
  &&deref_iterator_2="&iterator_&deref_dbg_var_name"
  &&deref_first_traversal="&first_traversal_&deref_dbg_var_name"
  
  
  var.if (&deref_iterator_2!=&deref_index || &deref_first_traversal==&TRUE)
   (
    if ("&deref_dbg_extra"!="0x0")
     (
	  &deref_dbg_var_name="&deref_dbg_var_name"+".&deref_dbg_extra"
	 )
    &get_next_timetick_val_ret=v.value(&deref_dbg_var_name[&deref_iterator_2].&deref_dbg_tt_name)
   )

RETURN

;============================================================================
; Print the merged debug logs for timer-services
;============================================================================
PRINT_MERGED_LOGS:
 
 ; Reset the debug var iterator
   GOSUB RESET_DEBUG_VAR_ITERATOR
 
 ; Init local vars
 &tt_from_dbg_var=0x1FFFFFFFFFFFFF
 &dbg_var_identifier=0xF00FF00F
 
 ; Open / Create the file for the output
 &uds_out_dir="&output_directory"+"\timer_unified_logs.log"

 OPEN #15 &uds_out_dir /Create
 
 while (&dbg_var_identifier!=0xFFFFFFFF)
  (
   ; reinitialize the local script vars
   &dbg_var_identifier=0xFFFFFFFF
   &iterator=0x1
   &tt_from_dbg_var=0x1FFFFFFFFFFFFF
   
   while (&iterator<=&number_of_debug_vars)
   (
	 GOSUB GET_NEXT_TIMETICK_VAL &iterator
	 
	 var.if (&get_next_timetick_val_ret!=0xFEEDF00D && &get_next_timetick_val_ret<=&tt_from_dbg_var)
	   (	 
	     &tt_from_dbg_var=&get_next_timetick_val_ret
		 &dbg_var_identifier=&iterator
	   )
	 ; increment the iterator
     &iterator=&iterator+0x1
   )
   
   ; Send the debug var data to the out file
   if (&dbg_var_identifier!=0xFFFFFFFF)
    (
	GOSUB WRITE_OUT_FILE &dbg_var_identifier
	)
  )
  
  CLOSE #15
  
  PRINT "Merged Logs created & updated : &uds_out_dir"
  
RETURN

;============================================================================
; Write the debug var info on the output file
;============================================================================
WRITE_OUT_FILE:
  ENTRY &debug_var_id
  
  &str_to_write=""
  &&deref_debug_var_name="&debug_var&debug_var_id"
  &&deref_debug_extra="&debug_var_extra&debug_var_id"
  
  &&deref_iterator="&iterator_&deref_debug_var_name"

  if ("&deref_debug_extra"!="0x0")
    (
	  &deref_debug_var_name_2="&deref_debug_var_name"+".&deref_debug_extra"
	  &str_to_write=var.string(&deref_debug_var_name_2[&deref_iterator])
	)  
  else
    (
	  &str_to_write=var.string(&deref_debug_var_name[&deref_iterator])
	)
  
  WRITE #15 "&deref_debug_var_name[&deref_iterator]= &str_to_write"
  
  ; Increment the index
  &iterator_&deref_debug_var_name=&deref_iterator+0x1
  
  ; Mark first_traversal as false if it is not so
  &&deref_first_traversal="&first_traversal_&deref_debug_var_name"
  if (&deref_first_traversal==&TRUE)
	 (
	  &first_traversal_&deref_debug_var_name=&FALSE
	 )
	
RETURN


;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;============================================================================
;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;============================================================================
;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;               D e b u g   S u b r o u t i n e s 
;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;============================================================================
;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;============================================================================
;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


;============================================================================
; General Debugging.
;============================================================================

GENERAL_TIMER_DEBUG:

  AREA.CREATE TLO
  WINPOS 60% 30% 40% 70% 0. 0. TLO
  AREA.VIEW TLO
  AREA.SELECT TLO
  
  print ""
  print ""
  print "######################################################################"
  print "                     G e n e r a l   D e b u g                        "
  print "######################################################################"
  print ""
  print ""

  &ret=0x0  
  ;
  ; Check first & last timer pointers
  ;
  &tmr_first=v.value(\timer\timers.active.list.first)
  &tmr_last=v.value(\timer\timers.active.list.last)
  &timers_processing=v.value(\timer\timers.processing)

  IF &timers_processing==1
  (
    print ""
    print "WARNING: Timer task is currently processing timers, linked list may appear corrupted, but may not actually be!"
    print ""
  )

  IF (&tmr_first==0)&&(&tmr_last!=0)
  (
    print "ERROR: Timer list appears to be corrupted.  FIRST timer is NULL, LAST is not. "
    print ""
    print ""
  )

  IF (&tmr_last==0)&&(&tmr_first!=0)
  (
    print "ERROR: Timer list appears to be corrupted.  LAST timer is NULL, FIRST is not. "
    print ""
    print ""
  )


  ;
  ; Check first & last timer pointers
  ;

  print ""
  print "Checking Bins..."
  print ""
  GOSUB TIMER_BIN_CHECK_DEBUG
  print ""
  print "Bin Checking Completed!"
  print ""
  print "######################################################################"

  print ""
  print "Checking Timer Groups..."
  print ""
  GOSUB TIMER_GROUP_LIST_CHECK 0x0 0x0
  print ""
  print "Group Checking Completed!"
  print ""
  print "######################################################################"  

  print ""
  print "Checking Timer Linked List..."
  print ""
  GOSUB TIMER_ACTIVE_LIST_CHECK_DEBUG
  print ""
  print "Timer Linked List Checking Completed!"
  print ""
  print "######################################################################"

  print ""
  print "Checking Timetick jumps cases..."
  print ""
  GOSUB CHECK_FOR_TIMETICK &FALSE
  print ""
  print "Timetick jump checking complete!"
  print ""
  print "######################################################################"  
  
  print ""
  print "Checking Callback Durations..."
  print ""
  GOSUB TIMER_CHECK_LONG_CALLBACKS
  print ""
  print "Callback Duration Checking Completed!"
  print ""
  print "######################################################################"

  
  print ""
  print "Checking For Delayed ISR..."
  print ""
  GOSUB TIMER_CHECK_FOR_DELAYED_ISR
  print ""
  print "Delayed ISR Checking Completed!"
  print ""
  print "######################################################################"

  
  print ""
  print ""
  AREA.CLOSE TLO
  
  WE.AREA.select TIMER

RETURN


TIMER_BIN_CHECK_DEBUG:
  
  &rain_check=y.type(timer_bin_pool)
  if (&rain_check!=0x3)
	(
	PRINT "Debug Variable : 'timer_bin_pool' is not availale in this build"
	RETURN
	)

  &bins_first=v.value((struct timer_bin_struct*)\timer\timers.bins.first)
  &bins_last=v.value((struct timer_bin_struct*)\timer\timers.bins.last)
  &bins_cnt=v.value((int*)\timer\timers.bins.count)

  ;
  ; Check pointers to see if they make sense
  ;

  IF (&bins_first==0)&&(&bins_last!=0)
  (
    print "ERROR:  Timer bin list appears corrupted.  FIRST bin is NULL, LAST is not"
    print ""
    print ""
  )

  IF (&bins_last==0)&&(&bins_first!=0)
  (
    print "ERROR:  Timer bin list appears corrupted.  LAST bin is NULL, FIRST is not"
    print ""
    print ""
  )

  ;
  ; Verify the list of bins
  ;

  IF (&bins_first!=0)&&(&bins_last!=0)
  (
    ;
    ; Check forward direction of list counts
    ;

    &forward_cnt=0
    &bin=&bins_first
    &last_bin=&bin

    WHILE &bin!=0
    (
      &forward_cnt=&forward_cnt+1
      &last_bin=&bin
      &bin=v.value(((struct timer_bin_struct*)&bin)->next_bin)
    )

    IF &forward_cnt!=&bins_cnt
    (
      print "ERROR: Detected Incorrect Number of Bins! Forward Count: &forward_cnt  Bins Count: &bins_cnt"
      print ""
      print ""
    )

    IF &last_bin!=&bins_last
    (
      print "ERROR:  Detected Incorrect Last Bin!  Actual: &bins_last  Propagated: &last_bin"
    )


    ;
    ; Check reverse direction of list counts
    ;

    &reverse_cnt=0
    &bin=&bins_last
    &last_bin=&bin


    WHILE &bin!=0
    (
      &reverse_cnt=&reverse_cnt+1
      &last_bin=&bin
      &bin=v.value(((struct timer_bin_struct*)&bin)->prev_bin)
    )

    IF &reverse_cnt!=&bins_cnt
    (
      print "ERROR: Detected Incorrect Number of Bins! Reverse Count: &reverse_cnt  Bins Count: &bins_cnt"
      print ""
      print ""
    )

    IF &last_bin!=&bins_first
    (
      print "ERROR:  Detected Incorrect First Bin!  Actual: &bins_first  Propagated: &last_bin"
    )

    ;
    ; Check forward direction of list logically
    ;

    &bin_front=&bins_first
    &bin_back=&bins_first
    &counter=1

    WHILE &counter<=(&bins_cnt-1)
    (
      ;
      ; Get Front Direction
      ;

      &bin_back=v.value(((struct timer_bin_struct*)&bin_front)->next_bin->prev_bin)

      IF &bin_back!=&bin_front
      (
        &bin_front_str=v.string((struct timer_bin_struct*)&bin_front)
        &bin_back_str=v.string((struct timer_bin_struct*)&bin_back)
        print "ERROR: Bin list corruption detected in the forward direction! Bin: &bin_front_str  Fwd->Back_Bin: &bin_back_str"
        print ""
        print ""
      )

      &bin_front=v.value(((struct timer_bin_struct*)&bin_front)->next_bin)
      
      &counter=&counter+1
    )
    

    ;
    ; Check reverse direction of list logically
    ;

    &bin_front=&bins_last
    &bin_back=&bins_last
    &counter=1

    WHILE &counter<=(&bins_cnt-1)
    (
      ;
      ; Get Reverse Direction
      ;

      &bin_front=v.value(((struct timer_bin_struct*)&bin_back)->prev_bin->next_bin)

      IF &bin_back!=&bin_front
      (
        &bin_front_str=v.string((struct timer_bin_struct*)&bin_front)
        &bin_back_str=v.string((struct timer_bin_struct*)&bin_back)
        print "ERROR: Bin list corruption detected in the reverse direction! Bin: &bin_back_str  Back->Fwd_Bin: &bin_front_str"
        print ""
        print ""
      )

      &bin_back=v.value(((struct timer_bin_struct*)&bin_front)->prev_bin)
      
      &counter=&counter+1
    )
    
    ;
    ; Check timers within bin & bin ordering
    ;  

    &bin=&bins_first

    WHILE (&bin!=0)
    (
      &tmr_first=v.value((timer_internal_type*)((struct timer_bin_struct*)&bin)->first)
      &tmr_last=v.value((timer_internal_type*)((struct timer_bin_struct*)&bin)->last)
      &cnt=0
      &max=v.value(((struct timer_bin_struct*)&bin)->count)
      &lower=v.value(((struct timer_bin_struct*)&bin)->lower)
      &upper=v.value(((struct timer_bin_struct*)&bin)->upper)

      WHILE (&tmr_first!=0)&&(&cnt<&max)
      (
        &expiry=v.value(((timer_internal_type*)&tmr_first)->expiry)
        IF (&expiry>&upper)
        (
          print "ERROR: Timer expiry exceeds the upper boundary of the bin! Bin: &bin  Timer: &tmr_first  Expiry: &expiry  Upper Bound: &upper"
        )

        IF (&expiry<&lower)
        (
          print "ERROR: Timer expiry exceeds the lower boundary of the bin! Bin: &bin  Timer: &tmr_first  Expiry: &expiry  Lower Bound: &lower"
        )

        IF (&cnt==(&max-1))&&(&tmr_first!=&tmr_last)
        (
          print "ERROR: Last timer in bin appears to be incorrect! Bin: &bin  Last Timer in Bin: &tmr_last  Traversed Last Timer: &tmr_first"          
        )

        &tmr_first=v.value(((timer_internal_type*)&tmr_first)->next)
        &cnt=&cnt+1
      )

      &bin=v.value(((struct timer_bin_struct*)&bin)->next_bin)
    )
  )


RETURN

TIMER_ACTIVE_LIST_CHECK_DEBUG:
  &tmr=v.value(\timer\timers.active.list.first)
  &tmr_first=v.value(\timer\timers.active.list.first)
  ;&sizeof_timers=v.sizeof(timer_buffer_ptr)/v.sizeof(timer_buffer_ptr[0])
  
  ; temporary solution
  &sizeof_timers=0x40
  &iterator=1

  ;
  ; Check for circular timer list
  ;

  WHILE (&tmr!=0)&&(&iterator<&sizeof_timers)
  (
    IF (&tmr==&tmr_first)&&(&iterator>1)
    (
      print "ERROR: Circular linked list found! First Timer: &tmr_first"
    )
  
    &iterator=&iterator+1
    &tmr=v.value(((timer_internal_type*)&tmr)->next)
  )

  IF &sizeof_timers==&iterator
  (
    print "ERROR: Circular linked list found! First Timer: &tmr_first"
  )

  ;
  ; Check that the expiry values in the timer list are in order
  ; and check that the timer list is not broken
  ;

  &tmr=v.value(\timer\timers.active.list.first)
  &last_tmr=v.value(\timer\timers.active.list.first)
  &last_expiry=0
  &expiry=0
  
  IF &tmr!=0
  (
    &last_expiry=v.value(((timer_internal_type*)&tmr)->expiry)
  )

  WHILE &tmr!=0
  (
    &expiry=v.value(((timer_internal_type*)&tmr)->expiry)
    IF &expiry<&last_expiry
    (
      &last_tmr_str=v.string((timer_internal_type*)&last_tmr)
      &tmr_str=v.string((timer_internal_type*)&tmr)
      print "ERROR: Timer expiries appear out of order on the timer linked list! Previous Timer:&last_tmr_str  Previous Expiry:&last_expiry  Timer:&tmr_str  Expiry:&expiry"
    )

    &tmr_next=v.value(((timer_internal_type*)&tmr)->next)
    IF &tmr_next!=0
    (
      &tmr_next_prev=v.value(((timer_internal_type*)&tmr_next)->prev)
      IF &tmr_next_prev!=&tmr
      (
        &last_tmr_str=v.string((timer_internal_type*)&tmr_next_prev)
        &tmr_str=v.string((timer_internal_type*)&tmr)
        print "ERROR: Timer linked list corruption detected! Timer->next->prev:&last_tmr_str  Timer:&tmr_str"
      )
    )

    &timer_state=v.value(((timer_internal_type*)&tmr)->timer_ext->timer_state)
    ; If timer is not in set state, display
    IF &timer_state!=0x0FEDCBAB 
    (
      &timer_state_val=v.string(((timer_internal_type*)&tmr)->timer_ext->timer_state)
      &tmr_str=v.string((timer_internal_type*)&tmr)
      &tmr_ext_str=v.string(((timer_internal_type*)&tmr)->timer_ext)
      print "ERROR:  Timer on linked list that is not in SET state! Timer State: &timer_state_val  Timer: &tmr_str  External Timer: &tmr_ext_str"
    )
	
	; Check the active list timer Sanity
    GOSUB INTERNAL_TIMER_SANITY_CHECK &tmr 0x0
	
    ; Check the External timer sanity
    &int_timers_ext_pointer=v.value(((timer_internal_type*)&tmr)->timer_ext)
	GOSUB EXTERNAL_TIMER_SANITY_CHECK &int_timers_ext_pointer 0x0
	
	; Check if the internal-external timer matches correctly
	GOSUB INTERNAL_EXTERNAL_TIMER_MATCH &tmr &int_timers_ext_pointer 0x0
	
    &last_tmr=&tmr
    &last_expiry=&expiry
    &tmr=v.value(((timer_internal_type*)&tmr)->next)
  )

RETURN

TIMER_CHECK_LONG_CALLBACKS:
  &sizeof_timers_expired=v.sizeof(timers_expired)/v.sizeof(timers_expired[0])
  &start_cnt=v.value(timer_expired_cnt)
  &curr_cnt=v.value(timer_expired_cnt)
  &iterator=1
  &processing_duration_measured=300
  &sizeof_timers_expired_slave1=0
  &sizeof_timers_expired_slave2=0
  &sizeof_timers_expired_slave3=0

  &ret=y.type(timers_expired_slave1)
  IF (&ret==0x3)  
  (
    &sizeof_timers_expired_slave1=v.sizeof(timers_expired_slave1)/v.sizeof(timers_expired_slave1[0])
  )
  &ret=y.type(timers_expired_slave2)
  IF (&ret==0x3)
  (
    &sizeof_timers_expired_slave2=v.sizeof(timers_expired_slave2)/v.sizeof(timers_expired_slave2[0])
  )
  &ret=y.type(timers_expired_slave3)
  IF (&ret==0x3)
  (
    &sizeof_timers_expired_slave3=v.sizeof(timers_expired_slave3)/v.sizeof(timers_expired_slave3[0])
  )


  ; Get processing duration
  IF &processing_duration_entered!=0
  (
    &processing_duration_measured=&processing_duration_entered
  )

  ;Print first half
  WHILE &curr_cnt<&sizeof_timers_expired
  (
    &timer_expired=var.string(timers_expired[&curr_cnt].timer_expired)
    &processing_duration=var.value(timers_expired[&curr_cnt].processing_time)
    
    IF &processing_duration>&processing_duration_measured
    (
      print "Long callback detected! Timer: &timer_expired  Processing Time: &processing_duration"
    )
    
    &curr_cnt=&curr_cnt+1
  )

  &curr_cnt=0
  ;Print second half
  WHILE &curr_cnt<&start_cnt
  (
    &timer_expired=var.string(timers_expired[&curr_cnt].timer_expired)
    &processing_duration=var.value(timers_expired[&curr_cnt].processing_time)
    
    IF &processing_duration>&processing_duration_measured
    (
      print "Long callback detected! Timer: &timer_expired  Processing Time: &processing_duration"
    )
    
    &curr_cnt=&curr_cnt+1
  )

  &ret=y.type(timers_expired_slave1)
  IF (&ret==0x3)
  (
    &start_cnt=v.value(timer_expired_cnt_slave1)
    &curr_cnt=v.value(timer_expired_cnt_slave1)
    ;Print first half
    WHILE &curr_cnt<&sizeof_timers_expired_slave1
    (
      &timer_expired=var.string(timers_expired_slave1[&curr_cnt].timer_expired)
      &processing_duration=var.value(timers_expired_slave1[&curr_cnt].processing_time)
      
      IF &processing_duration>&processing_duration_measured
      (
        print "Long callback detected! Timer: &timer_expired  Processing Time: &processing_duration"
      )
      
      &curr_cnt=&curr_cnt+1
    )

    &curr_cnt=0
    ;Print second half
    WHILE &curr_cnt<&start_cnt
    (
      &timer_expired=var.string(timers_expired_slave1[&curr_cnt].timer_expired)
      &processing_duration=var.value(timers_expired_slave1[&curr_cnt].processing_time)
      
      IF &processing_duration>&processing_duration_measured
      (
        print "Long callback detected! Timer: &timer_expired  Processing Time: &processing_duration"
      )
      
      &curr_cnt=&curr_cnt+1
    )
  )

  &ret=y.type(timers_expired_slave2)
  IF (&ret==0x3)
  (
    &start_cnt=v.value(timer_expired_cnt_slave2)
    &curr_cnt=v.value(timer_expired_cnt_slave2)
    ;Print first half
    WHILE &curr_cnt<&sizeof_timers_expired_slave2
    (
      &timer_expired=var.string(timers_expired_slave2[&curr_cnt].timer_expired)
      &processing_duration=var.value(timers_expired_slave2[&curr_cnt].processing_time)
      
      IF &processing_duration>&processing_duration_measured
      (
        print "Long callback detected! Timer: &timer_expired  Processing Time: &processing_duration"
      )
      
      &curr_cnt=&curr_cnt+1
    )

    &curr_cnt=0
    ;Print second half
    WHILE &curr_cnt<&start_cnt
    (
      &timer_expired=var.string(timers_expired_slave2[&curr_cnt].timer_expired)
      &processing_duration=var.value(timers_expired_slave2[&curr_cnt].processing_time)
      
      IF &processing_duration>&processing_duration_measured
      (
        print "Long callback detected! Timer: &timer_expired  Processing Time: &processing_duration"
      )
      
      &curr_cnt=&curr_cnt+1
    )
  )

  &ret=y.type(timers_expired_slave3)
  IF (&ret==0x3)
  (
    &start_cnt=v.value(timer_expired_cnt_slave3)
    &curr_cnt=v.value(timer_expired_cnt_slave3)
    ;Print first half
    WHILE &curr_cnt<&sizeof_timers_expired_slave3
    (
      &timer_expired=var.string(timers_expired_slave3[&curr_cnt].timer_expired)
      &processing_duration=var.value(timers_expired_slave3[&curr_cnt].processing_time)
      
      IF &processing_duration>&processing_duration_measured
      (
        print "Long callback detected! Timer: &timer_expired  Processing Time: &processing_duration"
      )
      
      &curr_cnt=&curr_cnt+1
    )

    &curr_cnt=0
    ;Print second half
    WHILE &curr_cnt<&start_cnt
    (
      &timer_expired=var.string(timers_expired_slave3[&curr_cnt].timer_expired)
      &processing_duration=var.value(timers_expired_slave3[&curr_cnt].processing_time)
      
      IF &processing_duration>&processing_duration_measured
      (
        print "Long callback detected! Timer: &timer_expired  Processing Time: &processing_duration"
      )
      
      &curr_cnt=&curr_cnt+1
    )
  )


RETURN

ESTIMATE_CURRENT_TIME:
  &ret=Y.TYPE(pInterruptData)
  if (&ret==0x3)
	(
	&log_cnt=v.value(pInterruptData.pLog.nIdx)
	&log_max=v.value(pInterruptData.pLog.nLogSize)

	IF &log_cnt==0
	(
		&log_cnt=&log_max-1
	)
	ELSE
	(
		&log_cnt=&log_cnt-1
	)
	
	; Set the global current time
	&tt_from_interrupts=v.value(pInterruptData.pLog.pEntries[&log_cnt].nTimeStamp)
	&tt_from_intr_str="tt_from_intr_strpInterruptData.pLog.pEntries[&log_cnt].nTimeStamp"
	print ""
	)
 else
   (
	    &tramp_iterator=0x0
		&size_debug_var=v.sizeof(tramp_log.entries)
		&element_size=v.sizeof(tramp_log.entries[0])
		&len_tramp_log=v.value(&size_debug_var / &element_size)

		var.if (&len_tramp_log==0x0)
			(
			&len_tramp_log=0x800
			)
	   &tt_from_interrupts=v.value(tramp_log.entries[0].timestamp)
			
	   while (&tramp_iterator<&len_tramp_log)
		(
		&temp_timetick=v.value(tramp_log.entries[&tramp_iterator].timestamp)
		
		if &temp_timetick>=&tt_from_interrupts
			(
			&tt_from_intr_str="tramp_log.entries[&tramp_iterator].timestamp"
			&tt_from_interrupts=&temp_timetick
			)
	
		&tramp_iterator=&tramp_iterator+1	
		)
   )
   
	
	;use aliter method since the current time is not available
	
	RETURN

TIMER_CHECK_FOR_DELAYED_ISR:
  &isr_time_val=v.value(\timer\timers.isr_time)
  &match_value=v.value(\timer\timers.match_value)
  &tolerance=(19200*50)

  ;Check to see if we are more than 10ms late for ISR
  IF (&match_value>&isr_time_val)&&(&current_time>(&match_value+&tolerance))
  (
    &delay=&current_time-&match_value
    print "Delayed ISR detected!  Match Value Set:&match_value   Current Time:&current_time   Last ISR:&isr_time_val   Delay:&delay"
  )

RETURN
